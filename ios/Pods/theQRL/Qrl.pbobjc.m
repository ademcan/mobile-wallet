// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qrl.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Qrl.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - QrlRoot

@implementation QrlRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - QrlRoot_FileDescriptor

static GPBFileDescriptor *QrlRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"qrl"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Empty

@implementation Empty


typedef struct Empty__storage_ {
  uint32_t _has_storage_[1];
} Empty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Empty class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Empty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNodeStateReq

@implementation GetNodeStateReq


typedef struct GetNodeStateReq__storage_ {
  uint32_t _has_storage_[1];
} GetNodeStateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNodeStateReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetNodeStateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNodeStateResp

@implementation GetNodeStateResp

@dynamic hasInfo, info;

typedef struct GetNodeStateResp__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo *info;
} GetNodeStateResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo),
        .number = GetNodeStateResp_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetNodeStateResp__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNodeStateResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNodeStateResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetKnownPeersReq

@implementation GetKnownPeersReq


typedef struct GetKnownPeersReq__storage_ {
  uint32_t _has_storage_[1];
} GetKnownPeersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetKnownPeersReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetKnownPeersReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetKnownPeersResp

@implementation GetKnownPeersResp

@dynamic hasNodeInfo, nodeInfo;
@dynamic knownPeersArray, knownPeersArray_Count;

typedef struct GetKnownPeersResp__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo *nodeInfo;
  NSMutableArray *knownPeersArray;
} GetKnownPeersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo),
        .number = GetKnownPeersResp_FieldNumber_NodeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetKnownPeersResp__storage_, nodeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "knownPeersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = GetKnownPeersResp_FieldNumber_KnownPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetKnownPeersResp__storage_, knownPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetKnownPeersResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetKnownPeersResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeersStatReq

@implementation GetPeersStatReq


typedef struct GetPeersStatReq__storage_ {
  uint32_t _has_storage_[1];
} GetPeersStatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeersStatReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetPeersStatReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeersStatResp

@implementation GetPeersStatResp

@dynamic peersStatArray, peersStatArray_Count;

typedef struct GetPeersStatResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersStatArray;
} GetPeersStatResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersStatArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerStat),
        .number = GetPeersStatResp_FieldNumber_PeersStatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPeersStatResp__storage_, peersStatArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeersStatResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeersStatResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetChainStatsReq

@implementation GetChainStatsReq


typedef struct GetChainStatsReq__storage_ {
  uint32_t _has_storage_[1];
} GetChainStatsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetChainStatsReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetChainStatsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetChainStatsResp

@implementation GetChainStatsResp

@dynamic stateSize;
@dynamic stateSizeMb;
@dynamic stateSizeGb;

typedef struct GetChainStatsResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *stateSizeMb;
  NSString *stateSizeGb;
  uint64_t stateSize;
} GetChainStatsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stateSize",
        .dataTypeSpecific.className = NULL,
        .number = GetChainStatsResp_FieldNumber_StateSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetChainStatsResp__storage_, stateSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "stateSizeMb",
        .dataTypeSpecific.className = NULL,
        .number = GetChainStatsResp_FieldNumber_StateSizeMb,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetChainStatsResp__storage_, stateSizeMb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stateSizeGb",
        .dataTypeSpecific.className = NULL,
        .number = GetChainStatsResp_FieldNumber_StateSizeGb,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetChainStatsResp__storage_, stateSizeGb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetChainStatsResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetChainStatsResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetStatsReq

@implementation GetStatsReq

@dynamic includeTimeseries;

typedef struct GetStatsReq__storage_ {
  uint32_t _has_storage_[1];
} GetStatsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "includeTimeseries",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsReq_FieldNumber_IncludeTimeseries,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetStatsReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetStatsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetStatsResp

@implementation GetStatsResp

@dynamic hasNodeInfo, nodeInfo;
@dynamic epoch;
@dynamic uptimeNetwork;
@dynamic blockLastReward;
@dynamic blockTimeMean;
@dynamic blockTimeSd;
@dynamic coinsTotalSupply;
@dynamic coinsEmitted;
@dynamic blockTimeseriesArray, blockTimeseriesArray_Count;

typedef struct GetStatsResp__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo *nodeInfo;
  NSMutableArray *blockTimeseriesArray;
  uint64_t epoch;
  uint64_t uptimeNetwork;
  uint64_t blockLastReward;
  uint64_t blockTimeMean;
  uint64_t blockTimeSd;
  uint64_t coinsTotalSupply;
  uint64_t coinsEmitted;
} GetStatsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo),
        .number = GetStatsResp_FieldNumber_NodeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, nodeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "epoch",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_Epoch,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, epoch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "uptimeNetwork",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_UptimeNetwork,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, uptimeNetwork),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockLastReward",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_BlockLastReward,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, blockLastReward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockTimeMean",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_BlockTimeMean,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, blockTimeMean),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockTimeSd",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_BlockTimeSd,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, blockTimeSd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "coinsTotalSupply",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_CoinsTotalSupply,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, coinsTotalSupply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "coinsEmitted",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_CoinsEmitted,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, coinsEmitted),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockTimeseriesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockDataPoint),
        .number = GetStatsResp_FieldNumber_BlockTimeseriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, blockTimeseriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetStatsResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetStatsResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressFromPKReq

@implementation GetAddressFromPKReq

@dynamic pk;

typedef struct GetAddressFromPKReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *pk;
} GetAddressFromPKReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressFromPKReq_FieldNumber_Pk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressFromPKReq__storage_, pk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressFromPKReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressFromPKReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressFromPKResp

@implementation GetAddressFromPKResp

@dynamic address;

typedef struct GetAddressFromPKResp__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
} GetAddressFromPKResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressFromPKResp_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressFromPKResp__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressFromPKResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressFromPKResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockDataPoint

@implementation BlockDataPoint

@dynamic number;
@dynamic difficulty;
@dynamic timestamp;
@dynamic timeLast;
@dynamic timeMovavg;
@dynamic hashPower;
@dynamic headerHash;
@dynamic headerHashPrev;

typedef struct BlockDataPoint__storage_ {
  uint32_t _has_storage_[1];
  float hashPower;
  NSString *difficulty;
  NSData *headerHash;
  NSData *headerHashPrev;
  uint64_t number;
  uint64_t timestamp;
  uint64_t timeLast;
  uint64_t timeMovavg;
} BlockDataPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_Number,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "difficulty",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_Difficulty,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, difficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "timeLast",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_TimeLast,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, timeLast),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "timeMovavg",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_TimeMovavg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, timeMovavg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "hashPower",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_HashPower,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, hashPower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "headerHash",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_HeaderHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, headerHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "headerHashPrev",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_HeaderHashPrev,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, headerHashPrev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockDataPoint class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockDataPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressStateReq

@implementation GetAddressStateReq

@dynamic address;
@dynamic excludeOtsBitfield;
@dynamic excludeTransactionHashes;

typedef struct GetAddressStateReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
} GetAddressStateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressStateReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressStateReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "excludeOtsBitfield",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressStateReq_FieldNumber_ExcludeOtsBitfield,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "excludeTransactionHashes",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressStateReq_FieldNumber_ExcludeTransactionHashes,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressStateReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressStateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressStateResp

@implementation GetAddressStateResp

@dynamic hasState, state;

typedef struct GetAddressStateResp__storage_ {
  uint32_t _has_storage_[1];
  AddressState *state;
} GetAddressStateResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressState),
        .number = GetAddressStateResp_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressStateResp__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressStateResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressStateResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetOptimizedAddressStateResp

@implementation GetOptimizedAddressStateResp

@dynamic hasState, state;

typedef struct GetOptimizedAddressStateResp__storage_ {
  uint32_t _has_storage_[1];
  OptimizedAddressState *state;
} GetOptimizedAddressStateResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(OptimizedAddressState),
        .number = GetOptimizedAddressStateResp_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetOptimizedAddressStateResp__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetOptimizedAddressStateResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetOptimizedAddressStateResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMultiSigAddressStateReq

@implementation GetMultiSigAddressStateReq

@dynamic address;

typedef struct GetMultiSigAddressStateReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
} GetMultiSigAddressStateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetMultiSigAddressStateReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMultiSigAddressStateReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMultiSigAddressStateReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMultiSigAddressStateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMultiSigAddressStateResp

@implementation GetMultiSigAddressStateResp

@dynamic hasState, state;

typedef struct GetMultiSigAddressStateResp__storage_ {
  uint32_t _has_storage_[1];
  MultiSigAddressState *state;
} GetMultiSigAddressStateResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(MultiSigAddressState),
        .number = GetMultiSigAddressStateResp_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMultiSigAddressStateResp__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMultiSigAddressStateResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMultiSigAddressStateResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IsSlaveReq

@implementation IsSlaveReq

@dynamic masterAddress;
@dynamic slavePk;

typedef struct IsSlaveReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddress;
  NSData *slavePk;
} IsSlaveReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddress",
        .dataTypeSpecific.className = NULL,
        .number = IsSlaveReq_FieldNumber_MasterAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IsSlaveReq__storage_, masterAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "slavePk",
        .dataTypeSpecific.className = NULL,
        .number = IsSlaveReq_FieldNumber_SlavePk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IsSlaveReq__storage_, slavePk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IsSlaveReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IsSlaveReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IsSlaveResp

@implementation IsSlaveResp

@dynamic result;

typedef struct IsSlaveResp__storage_ {
  uint32_t _has_storage_[1];
} IsSlaveResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = IsSlaveResp_FieldNumber_Result,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IsSlaveResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IsSlaveResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ParseAddressReq

@implementation ParseAddressReq

@dynamic address;

typedef struct ParseAddressReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
} ParseAddressReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ParseAddressReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ParseAddressReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ParseAddressReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ParseAddressReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ParseAddressResp

@implementation ParseAddressResp

@dynamic isValid;
@dynamic hasDesc, desc;

typedef struct ParseAddressResp__storage_ {
  uint32_t _has_storage_[1];
  AddressDescriptor *desc;
} ParseAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isValid",
        .dataTypeSpecific.className = NULL,
        .number = ParseAddressResp_FieldNumber_IsValid,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressDescriptor),
        .number = ParseAddressResp_FieldNumber_Desc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ParseAddressResp__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ParseAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ParseAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetObjectReq

@implementation GetObjectReq

@dynamic query;

typedef struct GetObjectReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *query;
} GetObjectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetObjectReq_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetObjectReq__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetObjectReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetObjectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetObjectResp

@implementation GetObjectResp

@dynamic resultOneOfCase;
@dynamic found;
@dynamic addressState;
@dynamic transaction;
@dynamic blockExtended;

typedef struct GetObjectResp__storage_ {
  uint32_t _has_storage_[2];
  OptimizedAddressState *addressState;
  TransactionExtended *transaction;
  BlockExtended *blockExtended;
} GetObjectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "found",
        .dataTypeSpecific.className = NULL,
        .number = GetObjectResp_FieldNumber_Found,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "addressState",
        .dataTypeSpecific.className = GPBStringifySymbol(OptimizedAddressState),
        .number = GetObjectResp_FieldNumber_AddressState,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetObjectResp__storage_, addressState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = GetObjectResp_FieldNumber_Transaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetObjectResp__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockExtended",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockExtended),
        .number = GetObjectResp_FieldNumber_BlockExtended,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetObjectResp__storage_, blockExtended),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetObjectResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetObjectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetObjectResp_ClearResultOneOfCase(GetObjectResp *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GetLatestDataReq

@implementation GetLatestDataReq

@dynamic filter;
@dynamic offset;
@dynamic quantity;

typedef struct GetLatestDataReq__storage_ {
  uint32_t _has_storage_[1];
  GetLatestDataReq_Filter filter;
  uint32_t offset;
  uint32_t quantity;
} GetLatestDataReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "filter",
        .dataTypeSpecific.enumDescFunc = GetLatestDataReq_Filter_EnumDescriptor,
        .number = GetLatestDataReq_FieldNumber_Filter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLatestDataReq__storage_, filter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "offset",
        .dataTypeSpecific.className = NULL,
        .number = GetLatestDataReq_FieldNumber_Offset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLatestDataReq__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "quantity",
        .dataTypeSpecific.className = NULL,
        .number = GetLatestDataReq_FieldNumber_Quantity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLatestDataReq__storage_, quantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLatestDataReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLatestDataReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetLatestDataReq_Filter_RawValue(GetLatestDataReq *message) {
  GPBDescriptor *descriptor = [GetLatestDataReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetLatestDataReq_FieldNumber_Filter];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetLatestDataReq_Filter_RawValue(GetLatestDataReq *message, int32_t value) {
  GPBDescriptor *descriptor = [GetLatestDataReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetLatestDataReq_FieldNumber_Filter];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetLatestDataReq_Filter

GPBEnumDescriptor *GetLatestDataReq_Filter_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "All\000Blockheaders\000Transactions\000Transactio"
        "nsUnconfirmed\000";
    static const int32_t values[] = {
        GetLatestDataReq_Filter_All,
        GetLatestDataReq_Filter_Blockheaders,
        GetLatestDataReq_Filter_Transactions,
        GetLatestDataReq_Filter_TransactionsUnconfirmed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetLatestDataReq_Filter)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetLatestDataReq_Filter_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetLatestDataReq_Filter_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetLatestDataReq_Filter_All:
    case GetLatestDataReq_Filter_Blockheaders:
    case GetLatestDataReq_Filter_Transactions:
    case GetLatestDataReq_Filter_TransactionsUnconfirmed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetLatestDataResp

@implementation GetLatestDataResp

@dynamic blockheadersArray, blockheadersArray_Count;
@dynamic transactionsArray, transactionsArray_Count;
@dynamic transactionsUnconfirmedArray, transactionsUnconfirmedArray_Count;

typedef struct GetLatestDataResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blockheadersArray;
  NSMutableArray *transactionsArray;
  NSMutableArray *transactionsUnconfirmedArray;
} GetLatestDataResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockheadersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeaderExtended),
        .number = GetLatestDataResp_FieldNumber_BlockheadersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLatestDataResp__storage_, blockheadersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = GetLatestDataResp_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLatestDataResp__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsUnconfirmedArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = GetLatestDataResp_FieldNumber_TransactionsUnconfirmedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLatestDataResp__storage_, transactionsUnconfirmedArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLatestDataResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLatestDataResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferCoinsReq

@implementation TransferCoinsReq

@dynamic masterAddr;
@dynamic addressesToArray, addressesToArray_Count;
@dynamic amountsArray, amountsArray_Count;
@dynamic messageData;
@dynamic fee;
@dynamic xmssPk;

typedef struct TransferCoinsReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSMutableArray *addressesToArray;
  GPBUInt64Array *amountsArray;
  NSData *messageData;
  NSData *xmssPk;
  uint64_t fee;
} TransferCoinsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addressesToArray",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_AddressesToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, addressesToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "messageData",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_MessageData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, messageData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_Fee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_XmssPk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferCoinsReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferCoinsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferCoinsResp

@implementation TransferCoinsResp

@dynamic hasExtendedTransactionUnsigned, extendedTransactionUnsigned;

typedef struct TransferCoinsResp__storage_ {
  uint32_t _has_storage_[1];
  TransactionExtended *extendedTransactionUnsigned;
} TransferCoinsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "extendedTransactionUnsigned",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = TransferCoinsResp_FieldNumber_ExtendedTransactionUnsigned,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferCoinsResp__storage_, extendedTransactionUnsigned),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferCoinsResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferCoinsResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushTransactionReq

@implementation PushTransactionReq

@dynamic hasTransactionSigned, transactionSigned;

typedef struct PushTransactionReq__storage_ {
  uint32_t _has_storage_[1];
  Transaction *transactionSigned;
} PushTransactionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionSigned",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = PushTransactionReq_FieldNumber_TransactionSigned,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushTransactionReq__storage_, transactionSigned),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushTransactionReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushTransactionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushTransactionResp

@implementation PushTransactionResp

@dynamic errorCode;
@dynamic errorDescription;
@dynamic txHash;

typedef struct PushTransactionResp__storage_ {
  uint32_t _has_storage_[1];
  PushTransactionResp_ResponseCode errorCode;
  NSString *errorDescription;
  NSData *txHash;
} PushTransactionResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.enumDescFunc = PushTransactionResp_ResponseCode_EnumDescriptor,
        .number = PushTransactionResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushTransactionResp__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "errorDescription",
        .dataTypeSpecific.className = NULL,
        .number = PushTransactionResp_FieldNumber_ErrorDescription,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushTransactionResp__storage_, errorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = PushTransactionResp_FieldNumber_TxHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushTransactionResp__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushTransactionResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushTransactionResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PushTransactionResp_ErrorCode_RawValue(PushTransactionResp *message) {
  GPBDescriptor *descriptor = [PushTransactionResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PushTransactionResp_FieldNumber_ErrorCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetPushTransactionResp_ErrorCode_RawValue(PushTransactionResp *message, int32_t value) {
  GPBDescriptor *descriptor = [PushTransactionResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PushTransactionResp_FieldNumber_ErrorCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum PushTransactionResp_ResponseCode

GPBEnumDescriptor *PushTransactionResp_ResponseCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Error\000ValidationFailed\000Submitted"
        "\000";
    static const int32_t values[] = {
        PushTransactionResp_ResponseCode_Unknown,
        PushTransactionResp_ResponseCode_Error,
        PushTransactionResp_ResponseCode_ValidationFailed,
        PushTransactionResp_ResponseCode_Submitted,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PushTransactionResp_ResponseCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PushTransactionResp_ResponseCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PushTransactionResp_ResponseCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case PushTransactionResp_ResponseCode_Unknown:
    case PushTransactionResp_ResponseCode_Error:
    case PushTransactionResp_ResponseCode_ValidationFailed:
    case PushTransactionResp_ResponseCode_Submitted:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MultiSigCreateTxnReq

@implementation MultiSigCreateTxnReq

@dynamic masterAddr;
@dynamic signatoriesArray, signatoriesArray_Count;
@dynamic weightsArray, weightsArray_Count;
@dynamic threshold;
@dynamic fee;
@dynamic xmssPk;

typedef struct MultiSigCreateTxnReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t threshold;
  NSData *masterAddr;
  NSMutableArray *signatoriesArray;
  GPBUInt32Array *weightsArray;
  NSData *xmssPk;
  uint64_t fee;
} MultiSigCreateTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigCreateTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiSigCreateTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signatoriesArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigCreateTxnReq_FieldNumber_SignatoriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigCreateTxnReq__storage_, signatoriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "weightsArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigCreateTxnReq_FieldNumber_WeightsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigCreateTxnReq__storage_, weightsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigCreateTxnReq_FieldNumber_Threshold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiSigCreateTxnReq__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigCreateTxnReq_FieldNumber_Fee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MultiSigCreateTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigCreateTxnReq_FieldNumber_XmssPk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MultiSigCreateTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiSigCreateTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiSigCreateTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiSigSpendTxnReq

@implementation MultiSigSpendTxnReq

@dynamic masterAddr;
@dynamic multiSigAddress;
@dynamic addrsToArray, addrsToArray_Count;
@dynamic amountsArray, amountsArray_Count;
@dynamic expiryBlockNumber;
@dynamic fee;
@dynamic xmssPk;

typedef struct MultiSigSpendTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSData *multiSigAddress;
  NSMutableArray *addrsToArray;
  GPBUInt64Array *amountsArray;
  NSData *xmssPk;
  uint64_t expiryBlockNumber;
  uint64_t fee;
} MultiSigSpendTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigSpendTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiSigSpendTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "multiSigAddress",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigSpendTxnReq_FieldNumber_MultiSigAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiSigSpendTxnReq__storage_, multiSigAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addrsToArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigSpendTxnReq_FieldNumber_AddrsToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigSpendTxnReq__storage_, addrsToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigSpendTxnReq_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigSpendTxnReq__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "expiryBlockNumber",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigSpendTxnReq_FieldNumber_ExpiryBlockNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MultiSigSpendTxnReq__storage_, expiryBlockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigSpendTxnReq_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MultiSigSpendTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigSpendTxnReq_FieldNumber_XmssPk,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MultiSigSpendTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiSigSpendTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiSigSpendTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiSigVoteTxnReq

@implementation MultiSigVoteTxnReq

@dynamic masterAddr;
@dynamic sharedKey;
@dynamic unvote;
@dynamic fee;
@dynamic xmssPk;

typedef struct MultiSigVoteTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSData *sharedKey;
  NSData *xmssPk;
  uint64_t fee;
} MultiSigVoteTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigVoteTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiSigVoteTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sharedKey",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigVoteTxnReq_FieldNumber_SharedKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiSigVoteTxnReq__storage_, sharedKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unvote",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigVoteTxnReq_FieldNumber_Unvote,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigVoteTxnReq_FieldNumber_Fee,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MultiSigVoteTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigVoteTxnReq_FieldNumber_XmssPk,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MultiSigVoteTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiSigVoteTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiSigVoteTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageTxnReq

@implementation MessageTxnReq

@dynamic masterAddr;
@dynamic message;
@dynamic addrTo;
@dynamic fee;
@dynamic xmssPk;

typedef struct MessageTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSData *message;
  NSData *addrTo;
  NSData *xmssPk;
  uint64_t fee;
} MessageTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addrTo",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_AddrTo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, addrTo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_XmssPk,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenTxnReq

@implementation TokenTxnReq

@dynamic masterAddr;
@dynamic symbol;
@dynamic name;
@dynamic owner;
@dynamic decimals;
@dynamic initialBalancesArray, initialBalancesArray_Count;
@dynamic fee;
@dynamic xmssPk;

typedef struct TokenTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSData *symbol;
  NSData *name;
  NSData *owner;
  NSMutableArray *initialBalancesArray;
  NSData *xmssPk;
  uint64_t decimals;
  uint64_t fee;
} TokenTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "symbol",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Symbol,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, symbol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "owner",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Owner,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "decimals",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Decimals,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, decimals),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "initialBalancesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressAmount),
        .number = TokenTxnReq_FieldNumber_InitialBalancesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, initialBalancesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Fee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_XmssPk,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferTokenTxnReq

@implementation TransferTokenTxnReq

@dynamic masterAddr;
@dynamic addressesToArray, addressesToArray_Count;
@dynamic tokenTxhash;
@dynamic amountsArray, amountsArray_Count;
@dynamic fee;
@dynamic xmssPk;

typedef struct TransferTokenTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSMutableArray *addressesToArray;
  NSData *tokenTxhash;
  GPBUInt64Array *amountsArray;
  NSData *xmssPk;
  uint64_t fee;
} TransferTokenTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addressesToArray",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_AddressesToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, addressesToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tokenTxhash",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_TokenTxhash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, tokenTxhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_Fee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_XmssPk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferTokenTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferTokenTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SlaveTxnReq

@implementation SlaveTxnReq

@dynamic masterAddr;
@dynamic slavePksArray, slavePksArray_Count;
@dynamic accessTypesArray, accessTypesArray_Count;
@dynamic fee;
@dynamic xmssPk;

typedef struct SlaveTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSMutableArray *slavePksArray;
  GPBUInt32Array *accessTypesArray;
  NSData *xmssPk;
  uint64_t fee;
} SlaveTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "slavePksArray",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_SlavePksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, slavePksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "accessTypesArray",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_AccessTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, accessTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_Fee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_XmssPk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SlaveTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SlaveTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LatticeTxnReq

@implementation LatticeTxnReq

@dynamic masterAddr;
@dynamic pk1;
@dynamic pk2;
@dynamic pk3;
@dynamic fee;
@dynamic xmssPk;

typedef struct LatticeTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSData *pk1;
  NSData *pk2;
  NSData *pk3;
  NSData *xmssPk;
  uint64_t fee;
} LatticeTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = LatticeTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LatticeTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pk1",
        .dataTypeSpecific.className = NULL,
        .number = LatticeTxnReq_FieldNumber_Pk1,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LatticeTxnReq__storage_, pk1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pk2",
        .dataTypeSpecific.className = NULL,
        .number = LatticeTxnReq_FieldNumber_Pk2,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LatticeTxnReq__storage_, pk2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pk3",
        .dataTypeSpecific.className = NULL,
        .number = LatticeTxnReq_FieldNumber_Pk3,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LatticeTxnReq__storage_, pk3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = LatticeTxnReq_FieldNumber_Fee,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LatticeTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = LatticeTxnReq_FieldNumber_XmssPk,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LatticeTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LatticeTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LatticeTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MiniTransaction

@implementation MiniTransaction

@dynamic transactionHash;
@dynamic out_p;
@dynamic amount;

typedef struct MiniTransaction__storage_ {
  uint32_t _has_storage_[1];
  NSString *transactionHash;
  uint64_t amount;
} MiniTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.className = NULL,
        .number = MiniTransaction_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MiniTransaction__storage_, transactionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "out_p",
        .dataTypeSpecific.className = NULL,
        .number = MiniTransaction_FieldNumber_Out_p,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = MiniTransaction_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MiniTransaction__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MiniTransaction class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MiniTransaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactionReq

@implementation GetTransactionReq

@dynamic txHash;

typedef struct GetTransactionReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *txHash;
} GetTransactionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionReq_FieldNumber_TxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTransactionReq__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactionReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTransactionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactionResp

@implementation GetTransactionResp

@dynamic hasTx, tx;
@dynamic confirmations;
@dynamic blockNumber;
@dynamic blockHeaderHash;
@dynamic timestamp;
@dynamic addrFrom;

typedef struct GetTransactionResp__storage_ {
  uint32_t _has_storage_[1];
  Transaction *tx;
  NSData *blockHeaderHash;
  NSData *addrFrom;
  uint64_t confirmations;
  uint64_t blockNumber;
  uint64_t timestamp;
} GetTransactionResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tx",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = GetTransactionResp_FieldNumber_Tx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTransactionResp__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmations",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionResp_FieldNumber_Confirmations,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTransactionResp__storage_, confirmations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionResp_FieldNumber_BlockNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTransactionResp__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockHeaderHash",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionResp_FieldNumber_BlockHeaderHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetTransactionResp__storage_, blockHeaderHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionResp_FieldNumber_Timestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetTransactionResp__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "addrFrom",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionResp_FieldNumber_AddrFrom,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetTransactionResp__storage_, addrFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactionResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTransactionResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMiniTransactionsByAddressReq

@implementation GetMiniTransactionsByAddressReq

@dynamic address;
@dynamic itemPerPage;
@dynamic pageNumber;

typedef struct GetMiniTransactionsByAddressReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  uint64_t itemPerPage;
  uint64_t pageNumber;
} GetMiniTransactionsByAddressReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetMiniTransactionsByAddressReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMiniTransactionsByAddressReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "itemPerPage",
        .dataTypeSpecific.className = NULL,
        .number = GetMiniTransactionsByAddressReq_FieldNumber_ItemPerPage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetMiniTransactionsByAddressReq__storage_, itemPerPage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.className = NULL,
        .number = GetMiniTransactionsByAddressReq_FieldNumber_PageNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetMiniTransactionsByAddressReq__storage_, pageNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMiniTransactionsByAddressReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMiniTransactionsByAddressReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMiniTransactionsByAddressResp

@implementation GetMiniTransactionsByAddressResp

@dynamic miniTransactionsArray, miniTransactionsArray_Count;
@dynamic balance;

typedef struct GetMiniTransactionsByAddressResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *miniTransactionsArray;
  uint64_t balance;
} GetMiniTransactionsByAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "miniTransactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MiniTransaction),
        .number = GetMiniTransactionsByAddressResp_FieldNumber_MiniTransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMiniTransactionsByAddressResp__storage_, miniTransactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = GetMiniTransactionsByAddressResp_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMiniTransactionsByAddressResp__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMiniTransactionsByAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMiniTransactionsByAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactionsByAddressReq

@implementation GetTransactionsByAddressReq

@dynamic address;
@dynamic itemPerPage;
@dynamic pageNumber;

typedef struct GetTransactionsByAddressReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  uint64_t itemPerPage;
  uint64_t pageNumber;
} GetTransactionsByAddressReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionsByAddressReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTransactionsByAddressReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "itemPerPage",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionsByAddressReq_FieldNumber_ItemPerPage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTransactionsByAddressReq__storage_, itemPerPage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.className = NULL,
        .number = GetTransactionsByAddressReq_FieldNumber_PageNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTransactionsByAddressReq__storage_, pageNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactionsByAddressReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTransactionsByAddressReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactionsByAddressResp

@implementation GetTransactionsByAddressResp

@dynamic transactionsDetailArray, transactionsDetailArray_Count;

typedef struct GetTransactionsByAddressResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsDetailArray;
} GetTransactionsByAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsDetailArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetTransactionResp),
        .number = GetTransactionsByAddressResp_FieldNumber_TransactionsDetailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTransactionsByAddressResp__storage_, transactionsDetailArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactionsByAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTransactionsByAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMultiSigSpendTxsByAddressReq

@implementation GetMultiSigSpendTxsByAddressReq

@dynamic address;
@dynamic itemPerPage;
@dynamic pageNumber;
@dynamic filterType;

typedef struct GetMultiSigSpendTxsByAddressReq__storage_ {
  uint32_t _has_storage_[1];
  GetMultiSigSpendTxsByAddressReq_FilterType filterType;
  NSData *address;
  uint64_t itemPerPage;
  uint64_t pageNumber;
} GetMultiSigSpendTxsByAddressReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetMultiSigSpendTxsByAddressReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMultiSigSpendTxsByAddressReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "itemPerPage",
        .dataTypeSpecific.className = NULL,
        .number = GetMultiSigSpendTxsByAddressReq_FieldNumber_ItemPerPage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetMultiSigSpendTxsByAddressReq__storage_, itemPerPage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.className = NULL,
        .number = GetMultiSigSpendTxsByAddressReq_FieldNumber_PageNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetMultiSigSpendTxsByAddressReq__storage_, pageNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "filterType",
        .dataTypeSpecific.enumDescFunc = GetMultiSigSpendTxsByAddressReq_FilterType_EnumDescriptor,
        .number = GetMultiSigSpendTxsByAddressReq_FieldNumber_FilterType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetMultiSigSpendTxsByAddressReq__storage_, filterType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMultiSigSpendTxsByAddressReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMultiSigSpendTxsByAddressReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetMultiSigSpendTxsByAddressReq_FilterType_RawValue(GetMultiSigSpendTxsByAddressReq *message) {
  GPBDescriptor *descriptor = [GetMultiSigSpendTxsByAddressReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetMultiSigSpendTxsByAddressReq_FieldNumber_FilterType];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetMultiSigSpendTxsByAddressReq_FilterType_RawValue(GetMultiSigSpendTxsByAddressReq *message, int32_t value) {
  GPBDescriptor *descriptor = [GetMultiSigSpendTxsByAddressReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetMultiSigSpendTxsByAddressReq_FieldNumber_FilterType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetMultiSigSpendTxsByAddressReq_FilterType

GPBEnumDescriptor *GetMultiSigSpendTxsByAddressReq_FilterType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "None\000ExecutedOnly\000NonExecuted\000Expired\000No"
        "nExpired\000NonExecutedExpired\000NonExecutedN"
        "onExpired\000";
    static const int32_t values[] = {
        GetMultiSigSpendTxsByAddressReq_FilterType_None,
        GetMultiSigSpendTxsByAddressReq_FilterType_ExecutedOnly,
        GetMultiSigSpendTxsByAddressReq_FilterType_NonExecuted,
        GetMultiSigSpendTxsByAddressReq_FilterType_Expired,
        GetMultiSigSpendTxsByAddressReq_FilterType_NonExpired,
        GetMultiSigSpendTxsByAddressReq_FilterType_NonExecutedExpired,
        GetMultiSigSpendTxsByAddressReq_FilterType_NonExecutedNonExpired,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetMultiSigSpendTxsByAddressReq_FilterType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetMultiSigSpendTxsByAddressReq_FilterType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetMultiSigSpendTxsByAddressReq_FilterType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetMultiSigSpendTxsByAddressReq_FilterType_None:
    case GetMultiSigSpendTxsByAddressReq_FilterType_ExecutedOnly:
    case GetMultiSigSpendTxsByAddressReq_FilterType_NonExecuted:
    case GetMultiSigSpendTxsByAddressReq_FilterType_Expired:
    case GetMultiSigSpendTxsByAddressReq_FilterType_NonExpired:
    case GetMultiSigSpendTxsByAddressReq_FilterType_NonExecutedExpired:
    case GetMultiSigSpendTxsByAddressReq_FilterType_NonExecutedNonExpired:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetMultiSigSpendTxsByAddressResp

@implementation GetMultiSigSpendTxsByAddressResp

@dynamic transactionsDetailArray, transactionsDetailArray_Count;

typedef struct GetMultiSigSpendTxsByAddressResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsDetailArray;
} GetMultiSigSpendTxsByAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsDetailArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetTransactionResp),
        .number = GetMultiSigSpendTxsByAddressResp_FieldNumber_TransactionsDetailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMultiSigSpendTxsByAddressResp__storage_, transactionsDetailArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMultiSigSpendTxsByAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMultiSigSpendTxsByAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVoteStatsReq

@implementation GetVoteStatsReq

@dynamic multiSigSpendTxHash;

typedef struct GetVoteStatsReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *multiSigSpendTxHash;
} GetVoteStatsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "multiSigSpendTxHash",
        .dataTypeSpecific.className = NULL,
        .number = GetVoteStatsReq_FieldNumber_MultiSigSpendTxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetVoteStatsReq__storage_, multiSigSpendTxHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVoteStatsReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVoteStatsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVoteStatsResp

@implementation GetVoteStatsResp

@dynamic hasVoteStats, voteStats;

typedef struct GetVoteStatsResp__storage_ {
  uint32_t _has_storage_[1];
  VoteStats *voteStats;
} GetVoteStatsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voteStats",
        .dataTypeSpecific.className = GPBStringifySymbol(VoteStats),
        .number = GetVoteStatsResp_FieldNumber_VoteStats,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetVoteStatsResp__storage_, voteStats),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVoteStatsResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVoteStatsResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInboxMessagesByAddressResp

@implementation GetInboxMessagesByAddressResp

@dynamic transactionsDetailArray, transactionsDetailArray_Count;

typedef struct GetInboxMessagesByAddressResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsDetailArray;
} GetInboxMessagesByAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsDetailArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetTransactionResp),
        .number = GetInboxMessagesByAddressResp_FieldNumber_TransactionsDetailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInboxMessagesByAddressResp__storage_, transactionsDetailArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInboxMessagesByAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInboxMessagesByAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InboxMessage

@implementation InboxMessage

@dynamic addrFrom;
@dynamic timestamp;
@dynamic message;
@dynamic txHash;
@dynamic blockNumber;

typedef struct InboxMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *addrFrom;
  NSData *message;
  NSData *txHash;
  uint64_t timestamp;
  uint64_t blockNumber;
} InboxMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrFrom",
        .dataTypeSpecific.className = NULL,
        .number = InboxMessage_FieldNumber_AddrFrom,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InboxMessage__storage_, addrFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = InboxMessage_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InboxMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = InboxMessage_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InboxMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = InboxMessage_FieldNumber_TxHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InboxMessage__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = InboxMessage_FieldNumber_BlockNumber,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InboxMessage__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InboxMessage class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InboxMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenDetail

@implementation TokenDetail

@dynamic tokenTxhash;
@dynamic name;
@dynamic symbol;
@dynamic balance;

typedef struct TokenDetail__storage_ {
  uint32_t _has_storage_[1];
  NSData *tokenTxhash;
  NSData *name;
  NSData *symbol;
  uint64_t balance;
} TokenDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenTxhash",
        .dataTypeSpecific.className = NULL,
        .number = TokenDetail_FieldNumber_TokenTxhash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenDetail__storage_, tokenTxhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = TokenDetail_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TokenDetail__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "symbol",
        .dataTypeSpecific.className = NULL,
        .number = TokenDetail_FieldNumber_Symbol,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TokenDetail__storage_, symbol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = TokenDetail_FieldNumber_Balance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TokenDetail__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenDetail class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTokensByAddressResp

@implementation GetTokensByAddressResp

@dynamic tokensDetailArray, tokensDetailArray_Count;

typedef struct GetTokensByAddressResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tokensDetailArray;
} GetTokensByAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokensDetailArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TokenDetail),
        .number = GetTokensByAddressResp_FieldNumber_TokensDetailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTokensByAddressResp__storage_, tokensDetailArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTokensByAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTokensByAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SlaveDetail

@implementation SlaveDetail

@dynamic slaveAddress;
@dynamic accessType;

typedef struct SlaveDetail__storage_ {
  uint32_t _has_storage_[1];
  NSData *slaveAddress;
  uint64_t accessType;
} SlaveDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slaveAddress",
        .dataTypeSpecific.className = NULL,
        .number = SlaveDetail_FieldNumber_SlaveAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SlaveDetail__storage_, slaveAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "accessType",
        .dataTypeSpecific.className = NULL,
        .number = SlaveDetail_FieldNumber_AccessType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SlaveDetail__storage_, accessType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SlaveDetail class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SlaveDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetSlavesByAddressResp

@implementation GetSlavesByAddressResp

@dynamic slavesDetailArray, slavesDetailArray_Count;

typedef struct GetSlavesByAddressResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *slavesDetailArray;
} GetSlavesByAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slavesDetailArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SlaveDetail),
        .number = GetSlavesByAddressResp_FieldNumber_SlavesDetailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetSlavesByAddressResp__storage_, slavesDetailArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetSlavesByAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetSlavesByAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LatticePKsDetail

@implementation LatticePKsDetail

@dynamic pk1;
@dynamic pk2;
@dynamic pk3;
@dynamic txHash;

typedef struct LatticePKsDetail__storage_ {
  uint32_t _has_storage_[1];
  NSData *pk1;
  NSData *pk2;
  NSData *pk3;
  NSData *txHash;
} LatticePKsDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk1",
        .dataTypeSpecific.className = NULL,
        .number = LatticePKsDetail_FieldNumber_Pk1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LatticePKsDetail__storage_, pk1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pk2",
        .dataTypeSpecific.className = NULL,
        .number = LatticePKsDetail_FieldNumber_Pk2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LatticePKsDetail__storage_, pk2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pk3",
        .dataTypeSpecific.className = NULL,
        .number = LatticePKsDetail_FieldNumber_Pk3,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LatticePKsDetail__storage_, pk3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = LatticePKsDetail_FieldNumber_TxHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LatticePKsDetail__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LatticePKsDetail class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LatticePKsDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLatticePKsByAddressResp

@implementation GetLatticePKsByAddressResp

@dynamic latticePksDetailArray, latticePksDetailArray_Count;

typedef struct GetLatticePKsByAddressResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *latticePksDetailArray;
} GetLatticePKsByAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latticePksDetailArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LatticePKsDetail),
        .number = GetLatticePKsByAddressResp_FieldNumber_LatticePksDetailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLatticePKsByAddressResp__storage_, latticePksDetailArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLatticePKsByAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLatticePKsByAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiSigDetail

@implementation MultiSigDetail

@dynamic address;
@dynamic balance;

typedef struct MultiSigDetail__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  uint64_t balance;
} MultiSigDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigDetail_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiSigDetail__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigDetail_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiSigDetail__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiSigDetail class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiSigDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMultiSigAddressesByAddressResp

@implementation GetMultiSigAddressesByAddressResp

@dynamic multiSigDetailArray, multiSigDetailArray_Count;

typedef struct GetMultiSigAddressesByAddressResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *multiSigDetailArray;
} GetMultiSigAddressesByAddressResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "multiSigDetailArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MultiSigDetail),
        .number = GetMultiSigAddressesByAddressResp_FieldNumber_MultiSigDetailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMultiSigAddressesByAddressResp__storage_, multiSigDetailArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMultiSigAddressesByAddressResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMultiSigAddressesByAddressResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBalanceReq

@implementation GetBalanceReq

@dynamic address;

typedef struct GetBalanceReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
} GetBalanceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetBalanceReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBalanceReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBalanceReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBalanceReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBalanceResp

@implementation GetBalanceResp

@dynamic balance;

typedef struct GetBalanceResp__storage_ {
  uint32_t _has_storage_[1];
  uint64_t balance;
} GetBalanceResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = GetBalanceResp_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBalanceResp__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBalanceResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBalanceResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTotalBalanceReq

@implementation GetTotalBalanceReq

@dynamic addressesArray, addressesArray_Count;

typedef struct GetTotalBalanceReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
} GetTotalBalanceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = GetTotalBalanceReq_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTotalBalanceReq__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTotalBalanceReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTotalBalanceReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTotalBalanceResp

@implementation GetTotalBalanceResp

@dynamic balance;

typedef struct GetTotalBalanceResp__storage_ {
  uint32_t _has_storage_[1];
  uint64_t balance;
} GetTotalBalanceResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = GetTotalBalanceResp_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTotalBalanceResp__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTotalBalanceResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTotalBalanceResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetOTSReq

@implementation GetOTSReq

@dynamic address;
@dynamic pageFrom;
@dynamic pageCount;
@dynamic unusedOtsIndexFrom;

typedef struct GetOTSReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  uint64_t pageFrom;
  uint64_t pageCount;
  uint64_t unusedOtsIndexFrom;
} GetOTSReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetOTSReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetOTSReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pageFrom",
        .dataTypeSpecific.className = NULL,
        .number = GetOTSReq_FieldNumber_PageFrom,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetOTSReq__storage_, pageFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pageCount",
        .dataTypeSpecific.className = NULL,
        .number = GetOTSReq_FieldNumber_PageCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetOTSReq__storage_, pageCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unusedOtsIndexFrom",
        .dataTypeSpecific.className = NULL,
        .number = GetOTSReq_FieldNumber_UnusedOtsIndexFrom,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetOTSReq__storage_, unusedOtsIndexFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetOTSReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetOTSReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OTSBitfieldByPage

@implementation OTSBitfieldByPage

@dynamic otsBitfieldArray, otsBitfieldArray_Count;
@dynamic pageNumber;

typedef struct OTSBitfieldByPage__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *otsBitfieldArray;
  uint64_t pageNumber;
} OTSBitfieldByPage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "otsBitfieldArray",
        .dataTypeSpecific.className = NULL,
        .number = OTSBitfieldByPage_FieldNumber_OtsBitfieldArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OTSBitfieldByPage__storage_, otsBitfieldArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.className = NULL,
        .number = OTSBitfieldByPage_FieldNumber_PageNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OTSBitfieldByPage__storage_, pageNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OTSBitfieldByPage class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OTSBitfieldByPage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetOTSResp

@implementation GetOTSResp

@dynamic otsBitfieldByPageArray, otsBitfieldByPageArray_Count;
@dynamic nextUnusedOtsIndex;
@dynamic unusedOtsIndexFound;

typedef struct GetOTSResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *otsBitfieldByPageArray;
  uint64_t nextUnusedOtsIndex;
} GetOTSResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "otsBitfieldByPageArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OTSBitfieldByPage),
        .number = GetOTSResp_FieldNumber_OtsBitfieldByPageArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetOTSResp__storage_, otsBitfieldByPageArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextUnusedOtsIndex",
        .dataTypeSpecific.className = NULL,
        .number = GetOTSResp_FieldNumber_NextUnusedOtsIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetOTSResp__storage_, nextUnusedOtsIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unusedOtsIndexFound",
        .dataTypeSpecific.className = NULL,
        .number = GetOTSResp_FieldNumber_UnusedOtsIndexFound,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetOTSResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetOTSResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetHeightReq

@implementation GetHeightReq


typedef struct GetHeightReq__storage_ {
  uint32_t _has_storage_[1];
} GetHeightReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetHeightReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetHeightReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetHeightResp

@implementation GetHeightResp

@dynamic height;

typedef struct GetHeightResp__storage_ {
  uint32_t _has_storage_[1];
  uint64_t height;
} GetHeightResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = GetHeightResp_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetHeightResp__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetHeightResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetHeightResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockReq

@implementation GetBlockReq

@dynamic headerHash;

typedef struct GetBlockReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *headerHash;
} GetBlockReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "headerHash",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockReq_FieldNumber_HeaderHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockReq__storage_, headerHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockResp

@implementation GetBlockResp

@dynamic hasBlock, block;

typedef struct GetBlockResp__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
} GetBlockResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = GetBlockResp_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockResp__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockByNumberReq

@implementation GetBlockByNumberReq

@dynamic blockNumber;

typedef struct GetBlockByNumberReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t blockNumber;
} GetBlockByNumberReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockByNumberReq_FieldNumber_BlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockByNumberReq__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockByNumberReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockByNumberReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockByNumberResp

@implementation GetBlockByNumberResp

@dynamic hasBlock, block;

typedef struct GetBlockByNumberResp__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
} GetBlockByNumberResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = GetBlockByNumberResp_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockByNumberResp__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockByNumberResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockByNumberResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLocalAddressesReq

@implementation GetLocalAddressesReq


typedef struct GetLocalAddressesReq__storage_ {
  uint32_t _has_storage_[1];
} GetLocalAddressesReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLocalAddressesReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetLocalAddressesReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLocalAddressesResp

@implementation GetLocalAddressesResp

@dynamic addressesArray, addressesArray_Count;

typedef struct GetLocalAddressesResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
} GetLocalAddressesResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = GetLocalAddressesResp_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLocalAddressesResp__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLocalAddressesResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLocalAddressesResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo

@implementation NodeInfo

@dynamic version;
@dynamic state;
@dynamic numConnections;
@dynamic numKnownPeers;
@dynamic uptime;
@dynamic blockHeight;
@dynamic blockLastHash;
@dynamic networkId;

typedef struct NodeInfo__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo_State state;
  uint32_t numConnections;
  uint32_t numKnownPeers;
  NSString *version;
  NSData *blockLastHash;
  NSString *networkId;
  uint64_t uptime;
  uint64_t blockHeight;
} NodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = NodeInfo_State_EnumDescriptor,
        .number = NodeInfo_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "numConnections",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_NumConnections,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, numConnections),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numKnownPeers",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_NumKnownPeers,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, numKnownPeers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uptime",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_Uptime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, uptime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_BlockHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockLastHash",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_BlockLastHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, blockLastHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "networkId",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_NetworkId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, networkId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NodeInfo_State_RawValue(NodeInfo *message) {
  GPBDescriptor *descriptor = [NodeInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NodeInfo_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetNodeInfo_State_RawValue(NodeInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [NodeInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NodeInfo_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum NodeInfo_State

GPBEnumDescriptor *NodeInfo_State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Unsynced\000Syncing\000Synced\000Forked\000";
    static const int32_t values[] = {
        NodeInfo_State_Unknown,
        NodeInfo_State_Unsynced,
        NodeInfo_State_Syncing,
        NodeInfo_State_Synced,
        NodeInfo_State_Forked,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NodeInfo_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NodeInfo_State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NodeInfo_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case NodeInfo_State_Unknown:
    case NodeInfo_State_Unsynced:
    case NodeInfo_State_Syncing:
    case NodeInfo_State_Synced:
    case NodeInfo_State_Forked:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AddressDescriptor

@implementation AddressDescriptor

@dynamic hashFunction;
@dynamic signatureScheme;
@dynamic treeHeight;
@dynamic signatures;
@dynamic addressFormat;

typedef struct AddressDescriptor__storage_ {
  uint32_t _has_storage_[1];
  uint32_t treeHeight;
  uint32_t signatures;
  NSString *hashFunction;
  NSString *signatureScheme;
  NSString *addressFormat;
} AddressDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashFunction",
        .dataTypeSpecific.className = NULL,
        .number = AddressDescriptor_FieldNumber_HashFunction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressDescriptor__storage_, hashFunction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signatureScheme",
        .dataTypeSpecific.className = NULL,
        .number = AddressDescriptor_FieldNumber_SignatureScheme,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressDescriptor__storage_, signatureScheme),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "treeHeight",
        .dataTypeSpecific.className = NULL,
        .number = AddressDescriptor_FieldNumber_TreeHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddressDescriptor__storage_, treeHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signatures",
        .dataTypeSpecific.className = NULL,
        .number = AddressDescriptor_FieldNumber_Signatures,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddressDescriptor__storage_, signatures),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "addressFormat",
        .dataTypeSpecific.className = NULL,
        .number = AddressDescriptor_FieldNumber_AddressFormat,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddressDescriptor__storage_, addressFormat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressDescriptor class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressDescriptor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StoredPeers

@implementation StoredPeers

@dynamic peersArray, peersArray_Count;

typedef struct StoredPeers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} StoredPeers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = StoredPeers_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StoredPeers__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StoredPeers class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StoredPeers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Peer

@implementation Peer

@dynamic ip;

typedef struct Peer__storage_ {
  uint32_t _has_storage_[1];
  NSString *ip;
} Peer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Peer__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peer class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressState

@implementation AddressState

@dynamic address;
@dynamic balance;
@dynamic nonce;
@dynamic otsBitfieldArray, otsBitfieldArray_Count;
@dynamic transactionHashesArray, transactionHashesArray_Count;
@dynamic tokens, tokens_Count;
@dynamic latticePkListArray, latticePkListArray_Count;
@dynamic slavePksAccessType, slavePksAccessType_Count;
@dynamic otsCounter;

typedef struct AddressState__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSMutableArray *otsBitfieldArray;
  NSMutableArray *transactionHashesArray;
  GPBStringUInt64Dictionary *tokens;
  NSMutableArray *latticePkListArray;
  GPBStringUInt32Dictionary *slavePksAccessType;
  uint64_t balance;
  uint64_t nonce;
  uint64_t otsCounter;
} AddressState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressState__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressState__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_Nonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddressState__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "otsBitfieldArray",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_OtsBitfieldArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, otsBitfieldArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transactionHashesArray",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_TransactionHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, transactionHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tokens",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_Tokens,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, tokens),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "latticePkListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LatticePK),
        .number = AddressState_FieldNumber_LatticePkListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, latticePkListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slavePksAccessType",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_SlavePksAccessType,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, slavePksAccessType),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "otsCounter",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_OtsCounter,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddressState__storage_, otsCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressState class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007\000latticePK_list\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OptimizedAddressState

@implementation OptimizedAddressState

@dynamic address;
@dynamic balance;
@dynamic nonce;
@dynamic otsBitfieldUsedPage;
@dynamic usedOtsKeyCount;
@dynamic transactionHashCount;
@dynamic tokensCount;
@dynamic slavesCount;
@dynamic latticePkCount;
@dynamic multiSigAddressCount;
@dynamic multiSigSpendCount;
@dynamic inboxMessageCount;
@dynamic foundationMultiSigSpendTxnHashArray, foundationMultiSigSpendTxnHashArray_Count;
@dynamic foundationMultiSigVoteTxnHashArray, foundationMultiSigVoteTxnHashArray_Count;
@dynamic unvotesArray, unvotesArray_Count;
@dynamic proposalVoteStatsArray, proposalVoteStatsArray_Count;

typedef struct OptimizedAddressState__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSMutableArray *foundationMultiSigSpendTxnHashArray;
  NSMutableArray *foundationMultiSigVoteTxnHashArray;
  NSMutableArray *unvotesArray;
  NSMutableArray *proposalVoteStatsArray;
  uint64_t balance;
  uint64_t nonce;
  uint64_t otsBitfieldUsedPage;
  uint64_t usedOtsKeyCount;
  uint64_t transactionHashCount;
  uint64_t tokensCount;
  uint64_t slavesCount;
  uint64_t latticePkCount;
  uint64_t multiSigAddressCount;
  uint64_t multiSigSpendCount;
  uint64_t inboxMessageCount;
} OptimizedAddressState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_Nonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "otsBitfieldUsedPage",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_OtsBitfieldUsedPage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, otsBitfieldUsedPage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "usedOtsKeyCount",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_UsedOtsKeyCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, usedOtsKeyCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "transactionHashCount",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_TransactionHashCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, transactionHashCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tokensCount",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_TokensCount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, tokensCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "slavesCount",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_SlavesCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, slavesCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "latticePkCount",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_LatticePkCount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, latticePkCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "multiSigAddressCount",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_MultiSigAddressCount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, multiSigAddressCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "multiSigSpendCount",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_MultiSigSpendCount,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, multiSigSpendCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inboxMessageCount",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_InboxMessageCount,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, inboxMessageCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "foundationMultiSigSpendTxnHashArray",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_FoundationMultiSigSpendTxnHashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, foundationMultiSigSpendTxnHashArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "foundationMultiSigVoteTxnHashArray",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_FoundationMultiSigVoteTxnHashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, foundationMultiSigVoteTxnHashArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unvotesArray",
        .dataTypeSpecific.className = NULL,
        .number = OptimizedAddressState_FieldNumber_UnvotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, unvotesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposalVoteStatsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = OptimizedAddressState_FieldNumber_ProposalVoteStatsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OptimizedAddressState__storage_, proposalVoteStatsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OptimizedAddressState class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OptimizedAddressState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiSigAddressState

@implementation MultiSigAddressState

@dynamic address;
@dynamic creationTxHash;
@dynamic nonce;
@dynamic balance;
@dynamic signatoriesArray, signatoriesArray_Count;
@dynamic weightsArray, weightsArray_Count;
@dynamic threshold;
@dynamic transactionHashCount;
@dynamic multiSigSpendCount;
@dynamic multiSigAddressCount;
@dynamic foundationMultiSigSpendTxnHashArray, foundationMultiSigSpendTxnHashArray_Count;
@dynamic foundationMultiSigVoteTxnHashArray, foundationMultiSigVoteTxnHashArray_Count;
@dynamic unvotesArray, unvotesArray_Count;
@dynamic proposalVoteStatsArray, proposalVoteStatsArray_Count;

typedef struct MultiSigAddressState__storage_ {
  uint32_t _has_storage_[1];
  uint32_t threshold;
  NSData *address;
  NSData *creationTxHash;
  NSMutableArray *signatoriesArray;
  GPBUInt32Array *weightsArray;
  NSMutableArray *foundationMultiSigSpendTxnHashArray;
  NSMutableArray *foundationMultiSigVoteTxnHashArray;
  NSMutableArray *unvotesArray;
  NSMutableArray *proposalVoteStatsArray;
  uint64_t nonce;
  uint64_t balance;
  uint64_t transactionHashCount;
  uint64_t multiSigSpendCount;
  uint64_t multiSigAddressCount;
} MultiSigAddressState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "creationTxHash",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_CreationTxHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, creationTxHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_Nonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_Balance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "signatoriesArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_SignatoriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, signatoriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "weightsArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_WeightsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, weightsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_Threshold,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "transactionHashCount",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_TransactionHashCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, transactionHashCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "multiSigSpendCount",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_MultiSigSpendCount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, multiSigSpendCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "multiSigAddressCount",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_MultiSigAddressCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, multiSigAddressCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "foundationMultiSigSpendTxnHashArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_FoundationMultiSigSpendTxnHashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, foundationMultiSigSpendTxnHashArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "foundationMultiSigVoteTxnHashArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_FoundationMultiSigVoteTxnHashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, foundationMultiSigVoteTxnHashArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unvotesArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressState_FieldNumber_UnvotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, unvotesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposalVoteStatsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = MultiSigAddressState_FieldNumber_ProposalVoteStatsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigAddressState__storage_, proposalVoteStatsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiSigAddressState class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiSigAddressState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MultiSigAddressesList

@implementation MultiSigAddressesList

@dynamic hashesArray, hashesArray_Count;

typedef struct MultiSigAddressesList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *hashesArray;
} MultiSigAddressesList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashesArray",
        .dataTypeSpecific.className = NULL,
        .number = MultiSigAddressesList_FieldNumber_HashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MultiSigAddressesList__storage_, hashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MultiSigAddressesList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MultiSigAddressesList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DataList

@implementation DataList

@dynamic valuesArray, valuesArray_Count;

typedef struct DataList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *valuesArray;
} DataList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valuesArray",
        .dataTypeSpecific.className = NULL,
        .number = DataList_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DataList__storage_, valuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Bitfield

@implementation Bitfield

@dynamic bitfieldsArray, bitfieldsArray_Count;

typedef struct Bitfield__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *bitfieldsArray;
} Bitfield__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bitfieldsArray",
        .dataTypeSpecific.className = NULL,
        .number = Bitfield_FieldNumber_BitfieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Bitfield__storage_, bitfieldsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Bitfield class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Bitfield__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionHashList

@implementation TransactionHashList

@dynamic hashesArray, hashesArray_Count;

typedef struct TransactionHashList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *hashesArray;
} TransactionHashList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashesArray",
        .dataTypeSpecific.className = NULL,
        .number = TransactionHashList_FieldNumber_HashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionHashList__storage_, hashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionHashList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionHashList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LatticePK

@implementation LatticePK

@dynamic kyberPk;
@dynamic dilithiumPk;

typedef struct LatticePK__storage_ {
  uint32_t _has_storage_[1];
  NSData *kyberPk;
  NSData *dilithiumPk;
} LatticePK__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "kyberPk",
        .dataTypeSpecific.className = NULL,
        .number = LatticePK_FieldNumber_KyberPk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LatticePK__storage_, kyberPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dilithiumPk",
        .dataTypeSpecific.className = NULL,
        .number = LatticePK_FieldNumber_DilithiumPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LatticePK__storage_, dilithiumPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LatticePK class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LatticePK__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressAmount

@implementation AddressAmount

@dynamic address;
@dynamic amount;

typedef struct AddressAmount__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  uint64_t amount;
} AddressAmount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddressAmount_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressAmount__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = AddressAmount_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressAmount__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressAmount class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressAmount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeader

@implementation BlockHeader

@dynamic hashHeader;
@dynamic blockNumber;
@dynamic timestampSeconds;
@dynamic hashHeaderPrev;
@dynamic rewardBlock;
@dynamic rewardFee;
@dynamic merkleRoot;
@dynamic miningNonce;
@dynamic extraNonce;

typedef struct BlockHeader__storage_ {
  uint32_t _has_storage_[1];
  uint32_t miningNonce;
  NSData *hashHeader;
  NSData *hashHeaderPrev;
  NSData *merkleRoot;
  uint64_t blockNumber;
  uint64_t timestampSeconds;
  uint64_t rewardBlock;
  uint64_t rewardFee;
  uint64_t extraNonce;
} BlockHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashHeader",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_HashHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, hashHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_BlockNumber,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "timestampSeconds",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_TimestampSeconds,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, timestampSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "hashHeaderPrev",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_HashHeaderPrev,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, hashHeaderPrev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rewardBlock",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_RewardBlock,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, rewardBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "rewardFee",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_RewardFee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, rewardFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "merkleRoot",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_MerkleRoot,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, merkleRoot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "miningNonce",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_MiningNonce,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, miningNonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extraNonce",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_ExtraNonce,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, extraNonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeader class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeaderExtended

@implementation BlockHeaderExtended

@dynamic hasHeader, header;
@dynamic hasTransactionCount, transactionCount;

typedef struct BlockHeaderExtended__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader *header;
  TransactionCount *transactionCount;
} BlockHeaderExtended__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = BlockHeaderExtended_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeaderExtended__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionCount",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionCount),
        .number = BlockHeaderExtended_FieldNumber_TransactionCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeaderExtended__storage_, transactionCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeaderExtended class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeaderExtended__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionCount

@implementation TransactionCount

@dynamic count, count_Count;

typedef struct TransactionCount__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32UInt32Dictionary *count;
} TransactionCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = TransactionCount_FieldNumber_Count,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionCount__storage_, count),
        .flags = GPBFieldMapKeyUInt32,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionCount class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionCount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionExtended

@implementation TransactionExtended

@dynamic hasHeader, header;
@dynamic hasTx, tx;
@dynamic addrFrom;
@dynamic size;
@dynamic timestampSeconds;

typedef struct TransactionExtended__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader *header;
  Transaction *tx;
  NSData *addrFrom;
  uint64_t size;
  uint64_t timestampSeconds;
} TransactionExtended__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = TransactionExtended_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tx",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionExtended_FieldNumber_Tx,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addrFrom",
        .dataTypeSpecific.className = NULL,
        .number = TransactionExtended_FieldNumber_AddrFrom,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, addrFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = TransactionExtended_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "timestampSeconds",
        .dataTypeSpecific.className = NULL,
        .number = TransactionExtended_FieldNumber_TimestampSeconds,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, timestampSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionExtended class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionExtended__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockExtended

@implementation BlockExtended

@dynamic hasHeader, header;
@dynamic extendedTransactionsArray, extendedTransactionsArray_Count;
@dynamic genesisBalanceArray, genesisBalanceArray_Count;
@dynamic size;

typedef struct BlockExtended__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader *header;
  NSMutableArray *extendedTransactionsArray;
  NSMutableArray *genesisBalanceArray;
  uint64_t size;
} BlockExtended__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = BlockExtended_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockExtended__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extendedTransactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = BlockExtended_FieldNumber_ExtendedTransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockExtended__storage_, extendedTransactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "genesisBalanceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GenesisBalance),
        .number = BlockExtended_FieldNumber_GenesisBalanceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockExtended__storage_, genesisBalanceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = BlockExtended_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockExtended__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockExtended class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockExtended__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic hasHeader, header;
@dynamic transactionsArray, transactionsArray_Count;
@dynamic genesisBalanceArray, genesisBalanceArray_Count;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader *header;
  NSMutableArray *transactionsArray;
  NSMutableArray *genesisBalanceArray;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = Block_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Block_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "genesisBalanceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GenesisBalance),
        .number = Block_FieldNumber_GenesisBalanceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, genesisBalanceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GenesisBalance

@implementation GenesisBalance

@dynamic address;
@dynamic balance;

typedef struct GenesisBalance__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  uint64_t balance;
} GenesisBalance__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GenesisBalance_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenesisBalance__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = GenesisBalance_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenesisBalance__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenesisBalance class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenesisBalance__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockMetaDataList

@implementation BlockMetaDataList

@dynamic blockNumberHashesArray, blockNumberHashesArray_Count;

typedef struct BlockMetaDataList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blockNumberHashesArray;
} BlockMetaDataList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumberHashesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockMetaData),
        .number = BlockMetaDataList_FieldNumber_BlockNumberHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockMetaDataList__storage_, blockNumberHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockMetaDataList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockMetaDataList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic transactionTypeOneOfCase;
@dynamic masterAddr;
@dynamic fee;
@dynamic publicKey;
@dynamic signature;
@dynamic nonce;
@dynamic transactionHash;
@dynamic transfer;
@dynamic coinbase;
@dynamic latticePk;
@dynamic message;
@dynamic token;
@dynamic transferToken;
@dynamic slave;
@dynamic multiSigCreate;
@dynamic multiSigSpend;
@dynamic multiSigVote;
@dynamic proposalCreate;
@dynamic proposalVote;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[2];
  NSData *masterAddr;
  NSData *publicKey;
  NSData *signature;
  NSData *transactionHash;
  Transaction_Transfer *transfer;
  Transaction_CoinBase *coinbase;
  Transaction_LatticePublicKey *latticePk;
  Transaction_Message *message;
  Transaction_Token *token;
  Transaction_TransferToken *transferToken;
  Transaction_Slave *slave;
  Transaction_MultiSigCreate *multiSigCreate;
  Transaction_MultiSigSpend *multiSigSpend;
  Transaction_MultiSigVote *multiSigVote;
  Transaction_ProposalCreate *proposalCreate;
  Transaction_ProposalVote *proposalVote;
  uint64_t fee;
  uint64_t nonce;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Fee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_PublicKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Signature,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Nonce,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "transactionHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TransactionHash,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, transactionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transfer",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Transfer),
        .number = Transaction_FieldNumber_Transfer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, transfer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "coinbase",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_CoinBase),
        .number = Transaction_FieldNumber_Coinbase,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, coinbase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latticePk",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_LatticePublicKey),
        .number = Transaction_FieldNumber_LatticePk,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, latticePk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Message),
        .number = Transaction_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Token),
        .number = Transaction_FieldNumber_Token,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transferToken",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_TransferToken),
        .number = Transaction_FieldNumber_TransferToken,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, transferToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slave",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Slave),
        .number = Transaction_FieldNumber_Slave,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, slave),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "multiSigCreate",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_MultiSigCreate),
        .number = Transaction_FieldNumber_MultiSigCreate,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, multiSigCreate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "multiSigSpend",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_MultiSigSpend),
        .number = Transaction_FieldNumber_MultiSigSpend,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, multiSigSpend),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "multiSigVote",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_MultiSigVote),
        .number = Transaction_FieldNumber_MultiSigVote,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, multiSigVote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proposalCreate",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_ProposalCreate),
        .number = Transaction_FieldNumber_ProposalCreate,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, proposalCreate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proposalVote",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_ProposalVote),
        .number = Transaction_FieldNumber_ProposalVote,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, proposalVote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "transactionType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Transaction_ClearTransactionTypeOneOfCase(Transaction *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Transaction_Transfer

@implementation Transaction_Transfer

@dynamic addrsToArray, addrsToArray_Count;
@dynamic amountsArray, amountsArray_Count;
@dynamic messageData;

typedef struct Transaction_Transfer__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addrsToArray;
  GPBUInt64Array *amountsArray;
  NSData *messageData;
} Transaction_Transfer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrsToArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Transfer_FieldNumber_AddrsToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Transfer__storage_, addrsToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Transfer_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Transfer__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "messageData",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Transfer_FieldNumber_MessageData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Transfer__storage_, messageData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Transfer class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Transfer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_CoinBase

@implementation Transaction_CoinBase

@dynamic addrTo;
@dynamic amount;

typedef struct Transaction_CoinBase__storage_ {
  uint32_t _has_storage_[1];
  NSData *addrTo;
  uint64_t amount;
} Transaction_CoinBase__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrTo",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_CoinBase_FieldNumber_AddrTo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_CoinBase__storage_, addrTo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_CoinBase_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_CoinBase__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_CoinBase class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_CoinBase__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_LatticePublicKey

@implementation Transaction_LatticePublicKey

@dynamic pk1;
@dynamic pk2;
@dynamic pk3;

typedef struct Transaction_LatticePublicKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *pk1;
  NSData *pk2;
  NSData *pk3;
} Transaction_LatticePublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk1",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_LatticePublicKey_FieldNumber_Pk1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_LatticePublicKey__storage_, pk1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pk2",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_LatticePublicKey_FieldNumber_Pk2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_LatticePublicKey__storage_, pk2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pk3",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_LatticePublicKey_FieldNumber_Pk3,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_LatticePublicKey__storage_, pk3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_LatticePublicKey class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_LatticePublicKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Message

@implementation Transaction_Message

@dynamic messageHash;
@dynamic addrTo;

typedef struct Transaction_Message__storage_ {
  uint32_t _has_storage_[1];
  NSData *messageHash;
  NSData *addrTo;
} Transaction_Message__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Message_FieldNumber_MessageHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Message__storage_, messageHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addrTo",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Message_FieldNumber_AddrTo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Message__storage_, addrTo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Message class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Message__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Token

@implementation Transaction_Token

@dynamic symbol;
@dynamic name;
@dynamic owner;
@dynamic decimals;
@dynamic initialBalancesArray, initialBalancesArray_Count;

typedef struct Transaction_Token__storage_ {
  uint32_t _has_storage_[1];
  NSData *symbol;
  NSData *name;
  NSData *owner;
  NSMutableArray *initialBalancesArray;
  uint64_t decimals;
} Transaction_Token__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "symbol",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Token_FieldNumber_Symbol,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, symbol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Token_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "owner",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Token_FieldNumber_Owner,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "decimals",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Token_FieldNumber_Decimals,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, decimals),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "initialBalancesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressAmount),
        .number = Transaction_Token_FieldNumber_InitialBalancesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, initialBalancesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Token class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Token__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_TransferToken

@implementation Transaction_TransferToken

@dynamic tokenTxhash;
@dynamic addrsToArray, addrsToArray_Count;
@dynamic amountsArray, amountsArray_Count;

typedef struct Transaction_TransferToken__storage_ {
  uint32_t _has_storage_[1];
  NSData *tokenTxhash;
  NSMutableArray *addrsToArray;
  GPBUInt64Array *amountsArray;
} Transaction_TransferToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenTxhash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_TransferToken_FieldNumber_TokenTxhash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_TransferToken__storage_, tokenTxhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addrsToArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_TransferToken_FieldNumber_AddrsToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_TransferToken__storage_, addrsToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_TransferToken_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_TransferToken__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_TransferToken class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_TransferToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Slave

@implementation Transaction_Slave

@dynamic slavePksArray, slavePksArray_Count;
@dynamic accessTypesArray, accessTypesArray_Count;

typedef struct Transaction_Slave__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *slavePksArray;
  GPBUInt32Array *accessTypesArray;
} Transaction_Slave__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slavePksArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Slave_FieldNumber_SlavePksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Slave__storage_, slavePksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "accessTypesArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Slave_FieldNumber_AccessTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Slave__storage_, accessTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Slave class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Slave__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_MultiSigCreate

@implementation Transaction_MultiSigCreate

@dynamic signatoriesArray, signatoriesArray_Count;
@dynamic weightsArray, weightsArray_Count;
@dynamic threshold;

typedef struct Transaction_MultiSigCreate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t threshold;
  NSMutableArray *signatoriesArray;
  GPBUInt32Array *weightsArray;
} Transaction_MultiSigCreate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signatoriesArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigCreate_FieldNumber_SignatoriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_MultiSigCreate__storage_, signatoriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "weightsArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigCreate_FieldNumber_WeightsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_MultiSigCreate__storage_, weightsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigCreate_FieldNumber_Threshold,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_MultiSigCreate__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_MultiSigCreate class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_MultiSigCreate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_MultiSigSpend

@implementation Transaction_MultiSigSpend

@dynamic multiSigAddress;
@dynamic addrsToArray, addrsToArray_Count;
@dynamic amountsArray, amountsArray_Count;
@dynamic expiryBlockNumber;

typedef struct Transaction_MultiSigSpend__storage_ {
  uint32_t _has_storage_[1];
  NSData *multiSigAddress;
  NSMutableArray *addrsToArray;
  GPBUInt64Array *amountsArray;
  uint64_t expiryBlockNumber;
} Transaction_MultiSigSpend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "multiSigAddress",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigSpend_FieldNumber_MultiSigAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_MultiSigSpend__storage_, multiSigAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addrsToArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigSpend_FieldNumber_AddrsToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_MultiSigSpend__storage_, addrsToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigSpend_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_MultiSigSpend__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "expiryBlockNumber",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigSpend_FieldNumber_ExpiryBlockNumber,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_MultiSigSpend__storage_, expiryBlockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_MultiSigSpend class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_MultiSigSpend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_MultiSigVote

@implementation Transaction_MultiSigVote

@dynamic sharedKey;
@dynamic unvote;
@dynamic prevTxHash;

typedef struct Transaction_MultiSigVote__storage_ {
  uint32_t _has_storage_[1];
  NSData *sharedKey;
  NSData *prevTxHash;
} Transaction_MultiSigVote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sharedKey",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigVote_FieldNumber_SharedKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_MultiSigVote__storage_, sharedKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unvote",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigVote_FieldNumber_Unvote,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "prevTxHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_MultiSigVote_FieldNumber_PrevTxHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_MultiSigVote__storage_, prevTxHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_MultiSigVote class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_MultiSigVote__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_ProposalCreate

@implementation Transaction_ProposalCreate

@dynamic proposalTypeOneOfCase;
@dynamic expiryBlockNumber;
@dynamic description_p;
@dynamic qip;
@dynamic config;
@dynamic other;

typedef struct Transaction_ProposalCreate__storage_ {
  uint32_t _has_storage_[2];
  NSString *description_p;
  Transaction_ProposalCreate_QIP *qip;
  Transaction_ProposalCreate_Config *config;
  Transaction_ProposalCreate_Other *other;
  uint64_t expiryBlockNumber;
} Transaction_ProposalCreate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "expiryBlockNumber",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_FieldNumber_ExpiryBlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate__storage_, expiryBlockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qip",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_ProposalCreate_QIP),
        .number = Transaction_ProposalCreate_FieldNumber_Qip,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate__storage_, qip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "config",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_ProposalCreate_Config),
        .number = Transaction_ProposalCreate_FieldNumber_Config,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "other",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_ProposalCreate_Other),
        .number = Transaction_ProposalCreate_FieldNumber_Other,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate__storage_, other),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_ProposalCreate class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_ProposalCreate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "proposalType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Transaction_ProposalCreate_ClearProposalTypeOneOfCase(Transaction_ProposalCreate *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Transaction_ProposalCreate_QIP

@implementation Transaction_ProposalCreate_QIP

@dynamic qipLink;

typedef struct Transaction_ProposalCreate_QIP__storage_ {
  uint32_t _has_storage_[1];
  NSString *qipLink;
} Transaction_ProposalCreate_QIP__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "qipLink",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_QIP_FieldNumber_QipLink,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_QIP__storage_, qipLink),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_ProposalCreate_QIP class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_ProposalCreate_QIP__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_ProposalCreate)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_ProposalCreate_Config

@implementation Transaction_ProposalCreate_Config

@dynamic changesBitfieldArray, changesBitfieldArray_Count;
@dynamic reorgLimit;
@dynamic maxCoinSupply;
@dynamic completeEmissionTimeSpanInYears;
@dynamic miningNonceOffset;
@dynamic extraNonceOffset;
@dynamic miningBlobSizeInBytes;
@dynamic blockTimingInSeconds;
@dynamic numberOfBlocksAnalyze;
@dynamic blockSizeMultiplier;
@dynamic blockMinSizeLimitInBytes;
@dynamic transactionMultiOutputLimit;
@dynamic messageMaxLength;
@dynamic tokenSymbolMaxLength;
@dynamic tokenNameMaxLength;
@dynamic latticePk1MaxLength;
@dynamic latticePk2MaxLength;
@dynamic latticePk3MaxLength;
@dynamic foundationMultiSigAddressThresholdPercentage;
@dynamic proposalThresholdPer;
@dynamic proposalDefaultOptionsArray, proposalDefaultOptionsArray_Count;
@dynamic descriptionMaxLength;
@dynamic optionsMaxNumber;
@dynamic optionMaxTextLength;
@dynamic proposalConfigActivationDelay;
@dynamic nMeasurement;
@dynamic kp;

typedef struct Transaction_ProposalCreate_Config__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *changesBitfieldArray;
  NSMutableArray *proposalDefaultOptionsArray;
  uint64_t reorgLimit;
  uint64_t maxCoinSupply;
  uint64_t completeEmissionTimeSpanInYears;
  uint64_t miningNonceOffset;
  uint64_t extraNonceOffset;
  uint64_t miningBlobSizeInBytes;
  uint64_t blockTimingInSeconds;
  uint64_t numberOfBlocksAnalyze;
  uint64_t blockSizeMultiplier;
  uint64_t blockMinSizeLimitInBytes;
  uint64_t transactionMultiOutputLimit;
  uint64_t messageMaxLength;
  uint64_t tokenSymbolMaxLength;
  uint64_t tokenNameMaxLength;
  uint64_t latticePk1MaxLength;
  uint64_t latticePk2MaxLength;
  uint64_t latticePk3MaxLength;
  uint64_t foundationMultiSigAddressThresholdPercentage;
  uint64_t proposalThresholdPer;
  uint64_t descriptionMaxLength;
  uint64_t optionsMaxNumber;
  uint64_t optionMaxTextLength;
  uint64_t proposalConfigActivationDelay;
  uint64_t nMeasurement;
  uint64_t kp;
} Transaction_ProposalCreate_Config__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "changesBitfieldArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_ChangesBitfieldArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, changesBitfieldArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "reorgLimit",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_ReorgLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, reorgLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "maxCoinSupply",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_MaxCoinSupply,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, maxCoinSupply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "completeEmissionTimeSpanInYears",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_CompleteEmissionTimeSpanInYears,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, completeEmissionTimeSpanInYears),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "miningNonceOffset",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_MiningNonceOffset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, miningNonceOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "extraNonceOffset",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_ExtraNonceOffset,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, extraNonceOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "miningBlobSizeInBytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_MiningBlobSizeInBytes,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, miningBlobSizeInBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockTimingInSeconds",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_BlockTimingInSeconds,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, blockTimingInSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "numberOfBlocksAnalyze",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_NumberOfBlocksAnalyze,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, numberOfBlocksAnalyze),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockSizeMultiplier",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_BlockSizeMultiplier,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, blockSizeMultiplier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockMinSizeLimitInBytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_BlockMinSizeLimitInBytes,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, blockMinSizeLimitInBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "transactionMultiOutputLimit",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_TransactionMultiOutputLimit,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, transactionMultiOutputLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "messageMaxLength",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_MessageMaxLength,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, messageMaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tokenSymbolMaxLength",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_TokenSymbolMaxLength,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, tokenSymbolMaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tokenNameMaxLength",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_TokenNameMaxLength,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, tokenNameMaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "latticePk1MaxLength",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_LatticePk1MaxLength,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, latticePk1MaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "latticePk2MaxLength",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_LatticePk2MaxLength,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, latticePk2MaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "latticePk3MaxLength",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_LatticePk3MaxLength,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, latticePk3MaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "foundationMultiSigAddressThresholdPercentage",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_FoundationMultiSigAddressThresholdPercentage,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, foundationMultiSigAddressThresholdPercentage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "proposalThresholdPer",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_ProposalThresholdPer,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, proposalThresholdPer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "proposalDefaultOptionsArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_ProposalDefaultOptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, proposalDefaultOptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionMaxLength",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_DescriptionMaxLength,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, descriptionMaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "optionsMaxNumber",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_OptionsMaxNumber,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, optionsMaxNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "optionMaxTextLength",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_OptionMaxTextLength,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, optionMaxTextLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "proposalConfigActivationDelay",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_ProposalConfigActivationDelay,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, proposalConfigActivationDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nMeasurement",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_NMeasurement,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, nMeasurement),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "kp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Config_FieldNumber_Kp,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Config__storage_, kp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_ProposalCreate_Config class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_ProposalCreate_Config__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\032A\253\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_ProposalCreate)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_ProposalCreate_Other

@implementation Transaction_ProposalCreate_Other

@dynamic optionsArray, optionsArray_Count;

typedef struct Transaction_ProposalCreate_Other__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *optionsArray;
} Transaction_ProposalCreate_Other__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "optionsArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalCreate_Other_FieldNumber_OptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_ProposalCreate_Other__storage_, optionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_ProposalCreate_Other class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_ProposalCreate_Other__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction_ProposalCreate)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_ProposalVote

@implementation Transaction_ProposalVote

@dynamic sharedKey;
@dynamic option;

typedef struct Transaction_ProposalVote__storage_ {
  uint32_t _has_storage_[1];
  uint32_t option;
  NSData *sharedKey;
} Transaction_ProposalVote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sharedKey",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalVote_FieldNumber_SharedKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_ProposalVote__storage_, sharedKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "option",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_ProposalVote_FieldNumber_Option,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_ProposalVote__storage_, option),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_ProposalVote class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_ProposalVote__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoteStats

@implementation VoteStats

@dynamic multiSigAddress;
@dynamic sharedKey;
@dynamic signatoriesArray, signatoriesArray_Count;
@dynamic txHashesArray, txHashesArray_Count;
@dynamic unvotesArray, unvotesArray_Count;
@dynamic expiryBlockNumber;
@dynamic totalWeight;
@dynamic executed;

typedef struct VoteStats__storage_ {
  uint32_t _has_storage_[1];
  NSData *multiSigAddress;
  NSData *sharedKey;
  NSMutableArray *signatoriesArray;
  NSMutableArray *txHashesArray;
  GPBBoolArray *unvotesArray;
  uint64_t expiryBlockNumber;
  uint64_t totalWeight;
} VoteStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "multiSigAddress",
        .dataTypeSpecific.className = NULL,
        .number = VoteStats_FieldNumber_MultiSigAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoteStats__storage_, multiSigAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sharedKey",
        .dataTypeSpecific.className = NULL,
        .number = VoteStats_FieldNumber_SharedKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoteStats__storage_, sharedKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signatoriesArray",
        .dataTypeSpecific.className = NULL,
        .number = VoteStats_FieldNumber_SignatoriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoteStats__storage_, signatoriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txHashesArray",
        .dataTypeSpecific.className = NULL,
        .number = VoteStats_FieldNumber_TxHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoteStats__storage_, txHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unvotesArray",
        .dataTypeSpecific.className = NULL,
        .number = VoteStats_FieldNumber_UnvotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoteStats__storage_, unvotesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "expiryBlockNumber",
        .dataTypeSpecific.className = NULL,
        .number = VoteStats_FieldNumber_ExpiryBlockNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoteStats__storage_, expiryBlockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "totalWeight",
        .dataTypeSpecific.className = NULL,
        .number = VoteStats_FieldNumber_TotalWeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VoteStats__storage_, totalWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "executed",
        .dataTypeSpecific.className = NULL,
        .number = VoteStats_FieldNumber_Executed,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoteStats class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoteStats__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProposalVoteStats

@implementation ProposalVoteStats

@dynamic addrFrom;
@dynamic sharedKey;
@dynamic proposalType;
@dynamic weightByOptionArray, weightByOptionArray_Count;
@dynamic expiryBlockNumber;
@dynamic executed;
@dynamic numberOfTxHashes;

typedef struct ProposalVoteStats__storage_ {
  uint32_t _has_storage_[1];
  NSData *addrFrom;
  NSData *sharedKey;
  NSString *proposalType;
  GPBUInt64Array *weightByOptionArray;
  uint64_t expiryBlockNumber;
  uint64_t numberOfTxHashes;
} ProposalVoteStats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrFrom",
        .dataTypeSpecific.className = NULL,
        .number = ProposalVoteStats_FieldNumber_AddrFrom,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProposalVoteStats__storage_, addrFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sharedKey",
        .dataTypeSpecific.className = NULL,
        .number = ProposalVoteStats_FieldNumber_SharedKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProposalVoteStats__storage_, sharedKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposalType",
        .dataTypeSpecific.className = NULL,
        .number = ProposalVoteStats_FieldNumber_ProposalType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProposalVoteStats__storage_, proposalType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weightByOptionArray",
        .dataTypeSpecific.className = NULL,
        .number = ProposalVoteStats_FieldNumber_WeightByOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProposalVoteStats__storage_, weightByOptionArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "expiryBlockNumber",
        .dataTypeSpecific.className = NULL,
        .number = ProposalVoteStats_FieldNumber_ExpiryBlockNumber,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ProposalVoteStats__storage_, expiryBlockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "executed",
        .dataTypeSpecific.className = NULL,
        .number = ProposalVoteStats_FieldNumber_Executed,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "numberOfTxHashes",
        .dataTypeSpecific.className = NULL,
        .number = ProposalVoteStats_FieldNumber_NumberOfTxHashes,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ProposalVoteStats__storage_, numberOfTxHashes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProposalVoteStats class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProposalVoteStats__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProposalRecord

@implementation ProposalRecord

@dynamic numberOfTxHashes;

typedef struct ProposalRecord__storage_ {
  uint32_t _has_storage_[1];
  uint64_t numberOfTxHashes;
} ProposalRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numberOfTxHashes",
        .dataTypeSpecific.className = NULL,
        .number = ProposalRecord_FieldNumber_NumberOfTxHashes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProposalRecord__storage_, numberOfTxHashes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProposalRecord class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProposalRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenList

@implementation TokenList

@dynamic tokenTxhashArray, tokenTxhashArray_Count;

typedef struct TokenList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tokenTxhashArray;
} TokenList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenTxhashArray",
        .dataTypeSpecific.className = NULL,
        .number = TokenList_FieldNumber_TokenTxhashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TokenList__storage_, tokenTxhashArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenBalance

@implementation TokenBalance

@dynamic balance;
@dynamic decimals;
@dynamic txHash;
@dynamic delete_p;

typedef struct TokenBalance__storage_ {
  uint32_t _has_storage_[1];
  NSData *txHash;
  uint64_t balance;
  uint64_t decimals;
} TokenBalance__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = TokenBalance_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenBalance__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "decimals",
        .dataTypeSpecific.className = NULL,
        .number = TokenBalance_FieldNumber_Decimals,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TokenBalance__storage_, decimals),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = TokenBalance_FieldNumber_TxHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TokenBalance__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "delete_p",
        .dataTypeSpecific.className = NULL,
        .number = TokenBalance_FieldNumber_Delete_p,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenBalance class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenBalance__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SlaveMetadata

@implementation SlaveMetadata

@dynamic accessType;
@dynamic txHash;
@dynamic delete_p;

typedef struct SlaveMetadata__storage_ {
  uint32_t _has_storage_[1];
  NSData *txHash;
  uint64_t accessType;
} SlaveMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessType",
        .dataTypeSpecific.className = NULL,
        .number = SlaveMetadata_FieldNumber_AccessType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SlaveMetadata__storage_, accessType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = SlaveMetadata_FieldNumber_TxHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SlaveMetadata__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "delete_p",
        .dataTypeSpecific.className = NULL,
        .number = SlaveMetadata_FieldNumber_Delete_p,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SlaveMetadata class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SlaveMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LatticePKMetadata

@implementation LatticePKMetadata

@dynamic enabled;
@dynamic txHash;
@dynamic delete_p;

typedef struct LatticePKMetadata__storage_ {
  uint32_t _has_storage_[1];
  NSData *txHash;
} LatticePKMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "enabled",
        .dataTypeSpecific.className = NULL,
        .number = LatticePKMetadata_FieldNumber_Enabled,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = LatticePKMetadata_FieldNumber_TxHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LatticePKMetadata__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "delete_p",
        .dataTypeSpecific.className = NULL,
        .number = LatticePKMetadata_FieldNumber_Delete_p,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LatticePKMetadata class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LatticePKMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenMetadata

@implementation TokenMetadata

@dynamic tokenTxhash;
@dynamic transferTokenTxHashesArray, transferTokenTxHashesArray_Count;

typedef struct TokenMetadata__storage_ {
  uint32_t _has_storage_[1];
  NSData *tokenTxhash;
  NSMutableArray *transferTokenTxHashesArray;
} TokenMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenTxhash",
        .dataTypeSpecific.className = NULL,
        .number = TokenMetadata_FieldNumber_TokenTxhash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenMetadata__storage_, tokenTxhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transferTokenTxHashesArray",
        .dataTypeSpecific.className = NULL,
        .number = TokenMetadata_FieldNumber_TransferTokenTxHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TokenMetadata__storage_, transferTokenTxHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenMetadata class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncryptedEphemeralMessage

@implementation EncryptedEphemeralMessage

@dynamic msgId;
@dynamic ttl;
@dynamic ttr;
@dynamic hasChannel, channel;
@dynamic nonce;
@dynamic payload;

typedef struct EncryptedEphemeralMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *msgId;
  EncryptedEphemeralMessage_Channel *channel;
  NSData *payload;
  uint64_t ttl;
  uint64_t ttr;
  uint64_t nonce;
} EncryptedEphemeralMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ttl",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_Ttl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, ttl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "ttr",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_Ttr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, ttr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(EncryptedEphemeralMessage_Channel),
        .number = EncryptedEphemeralMessage_FieldNumber_Channel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_Nonce,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_Payload,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptedEphemeralMessage class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptedEphemeralMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncryptedEphemeralMessage_Channel

@implementation EncryptedEphemeralMessage_Channel

@dynamic encAes256Symkey;

typedef struct EncryptedEphemeralMessage_Channel__storage_ {
  uint32_t _has_storage_[1];
  NSData *encAes256Symkey;
} EncryptedEphemeralMessage_Channel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encAes256Symkey",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_Channel_FieldNumber_EncAes256Symkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage_Channel__storage_, encAes256Symkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptedEphemeralMessage_Channel class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptedEphemeralMessage_Channel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(EncryptedEphemeralMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressList

@implementation AddressList

@dynamic addressesArray, addressesArray_Count;

typedef struct AddressList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
} AddressList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = AddressList_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressList__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeightData

@implementation BlockHeightData

@dynamic blockNumber;
@dynamic blockHeaderhash;
@dynamic cumulativeDifficulty;

typedef struct BlockHeightData__storage_ {
  uint32_t _has_storage_[1];
  NSData *blockHeaderhash;
  NSData *cumulativeDifficulty;
  uint64_t blockNumber;
} BlockHeightData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeightData_FieldNumber_BlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeightData__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockHeaderhash",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeightData_FieldNumber_BlockHeaderhash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeightData__storage_, blockHeaderhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cumulativeDifficulty",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeightData_FieldNumber_CumulativeDifficulty,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockHeightData__storage_, cumulativeDifficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeightData class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeightData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockMetaData

@implementation BlockMetaData

@dynamic blockDifficulty;
@dynamic cumulativeDifficulty;
@dynamic childHeaderhashesArray, childHeaderhashesArray_Count;
@dynamic lastNHeaderhashesArray, lastNHeaderhashesArray_Count;

typedef struct BlockMetaData__storage_ {
  uint32_t _has_storage_[1];
  NSData *blockDifficulty;
  NSData *cumulativeDifficulty;
  NSMutableArray *childHeaderhashesArray;
  NSMutableArray *lastNHeaderhashesArray;
} BlockMetaData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockDifficulty",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_BlockDifficulty,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockMetaData__storage_, blockDifficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cumulativeDifficulty",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_CumulativeDifficulty,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockMetaData__storage_, cumulativeDifficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "childHeaderhashesArray",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_ChildHeaderhashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockMetaData__storage_, childHeaderhashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "lastNHeaderhashesArray",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_LastNHeaderhashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockMetaData__storage_, lastNHeaderhashesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockMetaData class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockMetaData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\000last_N_headerhashes\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockNumberMapping

@implementation BlockNumberMapping

@dynamic headerhash;
@dynamic prevHeaderhash;

typedef struct BlockNumberMapping__storage_ {
  uint32_t _has_storage_[1];
  NSData *headerhash;
  NSData *prevHeaderhash;
} BlockNumberMapping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "headerhash",
        .dataTypeSpecific.className = NULL,
        .number = BlockNumberMapping_FieldNumber_Headerhash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockNumberMapping__storage_, headerhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prevHeaderhash",
        .dataTypeSpecific.className = NULL,
        .number = BlockNumberMapping_FieldNumber_PrevHeaderhash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockNumberMapping__storage_, prevHeaderhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockNumberMapping class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockNumberMapping__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerStat

@implementation PeerStat

@dynamic peerIp;
@dynamic port;
@dynamic hasNodeChainState, nodeChainState;

typedef struct PeerStat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSData *peerIp;
  NodeChainState *nodeChainState;
} PeerStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerIp",
        .dataTypeSpecific.className = NULL,
        .number = PeerStat_FieldNumber_PeerIp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerStat__storage_, peerIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = PeerStat_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeerStat__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nodeChainState",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeChainState),
        .number = PeerStat_FieldNumber_NodeChainState,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PeerStat__storage_, nodeChainState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerStat class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerStat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeChainState

@implementation NodeChainState

@dynamic blockNumber;
@dynamic headerHash;
@dynamic cumulativeDifficulty;
@dynamic version;
@dynamic timestamp;

typedef struct NodeChainState__storage_ {
  uint32_t _has_storage_[1];
  NSData *headerHash;
  NSData *cumulativeDifficulty;
  NSString *version;
  uint64_t blockNumber;
  uint64_t timestamp;
} NodeChainState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_BlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "headerHash",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_HeaderHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, headerHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cumulativeDifficulty",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_CumulativeDifficulty,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, cumulativeDifficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_Version,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_Timestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeChainState class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeChainState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeHeaderHash

@implementation NodeHeaderHash

@dynamic blockNumber;
@dynamic headerhashesArray, headerhashesArray_Count;

typedef struct NodeHeaderHash__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *headerhashesArray;
  uint64_t blockNumber;
} NodeHeaderHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = NodeHeaderHash_FieldNumber_BlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeHeaderHash__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "headerhashesArray",
        .dataTypeSpecific.className = NULL,
        .number = NodeHeaderHash_FieldNumber_HeaderhashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeHeaderHash__storage_, headerhashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeHeaderHash class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeHeaderHash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - P2PAcknowledgement

@implementation P2PAcknowledgement

@dynamic bytesProcessed;

typedef struct P2PAcknowledgement__storage_ {
  uint32_t _has_storage_[1];
  uint32_t bytesProcessed;
} P2PAcknowledgement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bytesProcessed",
        .dataTypeSpecific.className = NULL,
        .number = P2PAcknowledgement_FieldNumber_BytesProcessed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(P2PAcknowledgement__storage_, bytesProcessed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[P2PAcknowledgement class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(P2PAcknowledgement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerInfo

@implementation PeerInfo

@dynamic peerIp;
@dynamic port;
@dynamic bannedTimestamp;
@dynamic credibility;
@dynamic lastConnectionsTimestampArray, lastConnectionsTimestampArray_Count;

typedef struct PeerInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  uint32_t bannedTimestamp;
  uint32_t credibility;
  NSData *peerIp;
  GPBUInt32Array *lastConnectionsTimestampArray;
} PeerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerIp",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_PeerIp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, peerIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bannedTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_BannedTimestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, bannedTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "credibility",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_Credibility,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, credibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastConnectionsTimestampArray",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_LastConnectionsTimestampArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, lastConnectionsTimestampArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerInfo class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Peers

@implementation Peers

@dynamic peerInfoListArray, peerInfoListArray_Count;

typedef struct Peers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peerInfoListArray;
} Peers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerInfo),
        .number = Peers_FieldNumber_PeerInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Peers__storage_, peerInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peers class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig

@implementation DevConfig

@dynamic prevStateKey;
@dynamic currentStateKey;
@dynamic activationHeaderHash;
@dynamic activationBlockNumber;
@dynamic hasChain, chain;
@dynamic hasBlock, block;
@dynamic hasTransaction, transaction;
@dynamic hasPow, pow;

typedef struct DevConfig__storage_ {
  uint32_t _has_storage_[1];
  NSData *prevStateKey;
  NSData *currentStateKey;
  NSData *activationHeaderHash;
  DevConfig_Chain *chain;
  DevConfig_Block *block;
  DevConfig_Transaction *transaction;
  DevConfig_POW *pow;
  uint64_t activationBlockNumber;
} DevConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prevStateKey",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_FieldNumber_PrevStateKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig__storage_, prevStateKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "currentStateKey",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_FieldNumber_CurrentStateKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig__storage_, currentStateKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "activationHeaderHash",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_FieldNumber_ActivationHeaderHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DevConfig__storage_, activationHeaderHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "activationBlockNumber",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_FieldNumber_ActivationBlockNumber,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DevConfig__storage_, activationBlockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chain",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Chain),
        .number = DevConfig_FieldNumber_Chain,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DevConfig__storage_, chain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Block),
        .number = DevConfig_FieldNumber_Block,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DevConfig__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Transaction),
        .number = DevConfig_FieldNumber_Transaction,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DevConfig__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pow",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_POW),
        .number = DevConfig_FieldNumber_Pow,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DevConfig__storage_, pow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Chain

@implementation DevConfig_Chain

@dynamic reorgLimit;
@dynamic maxCoinSupply;
@dynamic completeEmissionTimeSpanInYears;

typedef struct DevConfig_Chain__storage_ {
  uint32_t _has_storage_[1];
  uint64_t reorgLimit;
  uint64_t maxCoinSupply;
  uint64_t completeEmissionTimeSpanInYears;
} DevConfig_Chain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reorgLimit",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Chain_FieldNumber_ReorgLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Chain__storage_, reorgLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "maxCoinSupply",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Chain_FieldNumber_MaxCoinSupply,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig_Chain__storage_, maxCoinSupply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "completeEmissionTimeSpanInYears",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Chain_FieldNumber_CompleteEmissionTimeSpanInYears,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DevConfig_Chain__storage_, completeEmissionTimeSpanInYears),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Chain class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Chain__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Block

@implementation DevConfig_Block

@dynamic miningNonceOffset;
@dynamic extraNonceOffset;
@dynamic miningBlobSizeInBytes;
@dynamic blockTimingInSeconds;
@dynamic hasBlockSizeController, blockSizeController;

typedef struct DevConfig_Block__storage_ {
  uint32_t _has_storage_[1];
  DevConfig_Block_BlockSizeController *blockSizeController;
  uint64_t miningNonceOffset;
  uint64_t extraNonceOffset;
  uint64_t miningBlobSizeInBytes;
  uint64_t blockTimingInSeconds;
} DevConfig_Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "miningNonceOffset",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Block_FieldNumber_MiningNonceOffset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Block__storage_, miningNonceOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "extraNonceOffset",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Block_FieldNumber_ExtraNonceOffset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig_Block__storage_, extraNonceOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "miningBlobSizeInBytes",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Block_FieldNumber_MiningBlobSizeInBytes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DevConfig_Block__storage_, miningBlobSizeInBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockTimingInSeconds",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Block_FieldNumber_BlockTimingInSeconds,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DevConfig_Block__storage_, blockTimingInSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockSizeController",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Block_BlockSizeController),
        .number = DevConfig_Block_FieldNumber_BlockSizeController,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DevConfig_Block__storage_, blockSizeController),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Block class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Block_BlockSizeController

@implementation DevConfig_Block_BlockSizeController

@dynamic numberOfBlocksAnalyze;
@dynamic sizeMultiplier;
@dynamic blockMinSizeLimitInBytes;

typedef struct DevConfig_Block_BlockSizeController__storage_ {
  uint32_t _has_storage_[1];
  uint64_t numberOfBlocksAnalyze;
  uint64_t sizeMultiplier;
  uint64_t blockMinSizeLimitInBytes;
} DevConfig_Block_BlockSizeController__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numberOfBlocksAnalyze",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Block_BlockSizeController_FieldNumber_NumberOfBlocksAnalyze,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Block_BlockSizeController__storage_, numberOfBlocksAnalyze),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sizeMultiplier",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Block_BlockSizeController_FieldNumber_SizeMultiplier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig_Block_BlockSizeController__storage_, sizeMultiplier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockMinSizeLimitInBytes",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Block_BlockSizeController_FieldNumber_BlockMinSizeLimitInBytes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DevConfig_Block_BlockSizeController__storage_, blockMinSizeLimitInBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Block_BlockSizeController class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Block_BlockSizeController__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig_Block)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Transaction

@implementation DevConfig_Transaction

@dynamic multiOutputLimit;
@dynamic hasMessage, message;
@dynamic hasSlave, slave;
@dynamic hasToken, token;
@dynamic hasLattice, lattice;
@dynamic hasFoundationMultiSig, foundationMultiSig;
@dynamic hasProposal, proposal;

typedef struct DevConfig_Transaction__storage_ {
  uint32_t _has_storage_[1];
  DevConfig_Transaction_Message *message;
  DevConfig_Transaction_Slave *slave;
  DevConfig_Transaction_Token *token;
  DevConfig_Transaction_Lattice *lattice;
  DevConfig_Transaction_FoundationMultiSig *foundationMultiSig;
  DevConfig_Transaction_Proposal *proposal;
  uint64_t multiOutputLimit;
} DevConfig_Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "multiOutputLimit",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_FieldNumber_MultiOutputLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Transaction__storage_, multiOutputLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Transaction_Message),
        .number = DevConfig_Transaction_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig_Transaction__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slave",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Transaction_Slave),
        .number = DevConfig_Transaction_FieldNumber_Slave,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DevConfig_Transaction__storage_, slave),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Transaction_Token),
        .number = DevConfig_Transaction_FieldNumber_Token,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DevConfig_Transaction__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lattice",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Transaction_Lattice),
        .number = DevConfig_Transaction_FieldNumber_Lattice,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DevConfig_Transaction__storage_, lattice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "foundationMultiSig",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Transaction_FoundationMultiSig),
        .number = DevConfig_Transaction_FieldNumber_FoundationMultiSig,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DevConfig_Transaction__storage_, foundationMultiSig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proposal",
        .dataTypeSpecific.className = GPBStringifySymbol(DevConfig_Transaction_Proposal),
        .number = DevConfig_Transaction_FieldNumber_Proposal,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DevConfig_Transaction__storage_, proposal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Transaction class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Transaction_Message

@implementation DevConfig_Transaction_Message

@dynamic maxLength;

typedef struct DevConfig_Transaction_Message__storage_ {
  uint32_t _has_storage_[1];
  uint64_t maxLength;
} DevConfig_Transaction_Message__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Message_FieldNumber_MaxLength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Message__storage_, maxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Transaction_Message class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Transaction_Message__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig_Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Transaction_Slave

@implementation DevConfig_Transaction_Slave

@dynamic slavePkMaxLength;

typedef struct DevConfig_Transaction_Slave__storage_ {
  uint32_t _has_storage_[1];
  uint64_t slavePkMaxLength;
} DevConfig_Transaction_Slave__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slavePkMaxLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Slave_FieldNumber_SlavePkMaxLength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Slave__storage_, slavePkMaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Transaction_Slave class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Transaction_Slave__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig_Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Transaction_Token

@implementation DevConfig_Transaction_Token

@dynamic symbolMaxLength;
@dynamic nameMaxLength;

typedef struct DevConfig_Transaction_Token__storage_ {
  uint32_t _has_storage_[1];
  uint64_t symbolMaxLength;
  uint64_t nameMaxLength;
} DevConfig_Transaction_Token__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "symbolMaxLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Token_FieldNumber_SymbolMaxLength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Token__storage_, symbolMaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nameMaxLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Token_FieldNumber_NameMaxLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Token__storage_, nameMaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Transaction_Token class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Transaction_Token__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig_Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Transaction_Lattice

@implementation DevConfig_Transaction_Lattice

@dynamic pk1MaxLength;
@dynamic pk2MaxLength;
@dynamic pk3MaxLength;

typedef struct DevConfig_Transaction_Lattice__storage_ {
  uint32_t _has_storage_[1];
  uint64_t pk1MaxLength;
  uint64_t pk2MaxLength;
  uint64_t pk3MaxLength;
} DevConfig_Transaction_Lattice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk1MaxLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Lattice_FieldNumber_Pk1MaxLength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Lattice__storage_, pk1MaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pk2MaxLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Lattice_FieldNumber_Pk2MaxLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Lattice__storage_, pk2MaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pk3MaxLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Lattice_FieldNumber_Pk3MaxLength,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Lattice__storage_, pk3MaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Transaction_Lattice class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Transaction_Lattice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig_Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Transaction_FoundationMultiSig

@implementation DevConfig_Transaction_FoundationMultiSig

@dynamic thresholdPercentage;

typedef struct DevConfig_Transaction_FoundationMultiSig__storage_ {
  uint32_t _has_storage_[1];
  uint64_t thresholdPercentage;
} DevConfig_Transaction_FoundationMultiSig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thresholdPercentage",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_FoundationMultiSig_FieldNumber_ThresholdPercentage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_FoundationMultiSig__storage_, thresholdPercentage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Transaction_FoundationMultiSig class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Transaction_FoundationMultiSig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig_Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_Transaction_Proposal

@implementation DevConfig_Transaction_Proposal

@dynamic thresholdPer;
@dynamic defaultOptionsArray, defaultOptionsArray_Count;
@dynamic descriptionMaxLength;
@dynamic optionsMaxNumber;
@dynamic optionMaxTextLength;
@dynamic proposalConfigActivationDelay;

typedef struct DevConfig_Transaction_Proposal__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *defaultOptionsArray;
  uint64_t thresholdPer;
  uint64_t descriptionMaxLength;
  uint64_t optionsMaxNumber;
  uint64_t optionMaxTextLength;
  uint64_t proposalConfigActivationDelay;
} DevConfig_Transaction_Proposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thresholdPer",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Proposal_FieldNumber_ThresholdPer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Proposal__storage_, thresholdPer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "defaultOptionsArray",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Proposal_FieldNumber_DefaultOptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Proposal__storage_, defaultOptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionMaxLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Proposal_FieldNumber_DescriptionMaxLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Proposal__storage_, descriptionMaxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "optionsMaxNumber",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Proposal_FieldNumber_OptionsMaxNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Proposal__storage_, optionsMaxNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "optionMaxTextLength",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Proposal_FieldNumber_OptionMaxTextLength,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Proposal__storage_, optionMaxTextLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "proposalConfigActivationDelay",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_Transaction_Proposal_FieldNumber_ProposalConfigActivationDelay,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DevConfig_Transaction_Proposal__storage_, proposalConfigActivationDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_Transaction_Proposal class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_Transaction_Proposal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig_Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevConfig_POW

@implementation DevConfig_POW

@dynamic nMeasurement;
@dynamic kp;

typedef struct DevConfig_POW__storage_ {
  uint32_t _has_storage_[1];
  uint64_t nMeasurement;
  uint64_t kp;
} DevConfig_POW__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nMeasurement",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_POW_FieldNumber_NMeasurement,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevConfig_POW__storage_, nMeasurement),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "kp",
        .dataTypeSpecific.className = NULL,
        .number = DevConfig_POW_FieldNumber_Kp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevConfig_POW__storage_, kp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevConfig_POW class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevConfig_POW__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001A\253\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DevConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
